<% layout('layout') -%>
  <% if (flash) { %>
    <div class="mb-4">
      <div
        class="px-4 py-3 rounded-lg border text-sm
        <%= flash.type === 'success' ? 'bg-green-500/10 border-green-600/30 text-green-300' : (flash.type === 'info' ? 'bg-blue-500/10 border-blue-600/30 text-blue-300' : 'bg-yellow-500/10 border-yellow-600/30 text-yellow-300') %>">
        <i
          class="ti <%= flash.type === 'success' ? 'ti-check' : (flash.type === 'info' ? 'ti-info-circle' : 'ti-alert-triangle') %> mr-2"></i>
        <%= flash.message %>
      </div>
      <!-- YouTube scheduling UI moved to layout sidebar -->
    </div>
    <% } %>

      <!-- Compact Indicators - Single Line -->
      <div class="bg-gray-800/50 rounded-lg px-3 py-2 mb-3 border border-gray-700/30">
        <div class="flex flex-wrap items-center justify-center gap-x-4 gap-y-2 text-sm">
          <!-- Quota Streams -->
          <div class="flex items-center gap-1.5">
            <i class="ti ti-video text-primary text-base"></i>
            <span class="text-gray-400">Streams:</span>
            <span class="font-semibold" id="quota-streams">0 / 0</span>
          </div>
          
          <div class="hidden sm:block h-4 w-px bg-gray-700"></div>
          
          <!-- Quota Storage -->
          <div class="flex items-center gap-1.5">
            <i class="ti ti-database text-blue-400 text-base"></i>
            <span class="text-gray-400">Storage:</span>
            <span class="font-semibold" id="quota-storage">0 / 0 GB</span>
          </div>
          
          <% if (user && user.user_role === 'admin') { %>
          <div class="hidden sm:block h-4 w-px bg-gray-700"></div>
          
          <!-- Disk (Admin only) -->
          <div class="flex items-center gap-1.5">
            <i class="ti ti-device-sd-card text-green-400 text-base"></i>
            <span class="text-gray-400">Disk:</span>
            <span class="font-semibold"><span id="disk-used">0</span> / <span id="disk-total">0</span> GB</span>
          </div>
          
          <div class="hidden sm:block h-4 w-px bg-gray-700"></div>
          
          <!-- Active Streams -->
          <div class="flex items-center gap-1.5">
            <i class="ti ti-broadcast text-purple-400 text-base"></i>
            <span class="text-gray-400">Active:</span>
            <span class="font-semibold" id="active-streams">0</span>
          </div>
          
          <div class="hidden sm:block h-4 w-px bg-gray-700"></div>
          
          <!-- CPU -->
          <div class="flex items-center gap-1.5">
            <i class="ti ti-cpu text-yellow-400 text-base"></i>
            <span class="text-gray-400">CPU:</span>
            <span class="font-semibold"><span id="cpu-usage">0</span>%</span>
          </div>
          
          <div class="hidden sm:block h-4 w-px bg-gray-700"></div>
          
          <!-- Memory -->
          <div class="flex items-center gap-1.5">
            <i class="ti ti-device-sd-card text-green-400 text-base"></i>
            <span class="text-gray-400">RAM:</span>
            <span class="font-semibold"><span id="memory-used">0</span> / <span id="memory-total">0</span> MB</span>
          </div>
          
          <div class="hidden sm:block h-4 w-px bg-gray-700"></div>
          
          <!-- Network -->
          <div class="flex items-center gap-1.5">
            <i class="ti ti-wifi text-cyan-400 text-base"></i>
            <span class="text-gray-400">Net:</span>
            <span class="font-semibold text-xs">
              <span class="text-blue-400">↑<span id="upload-speed">0</span></span>
              <span class="text-green-400 ml-1">↓<span id="download-speed">0</span></span>
            </span>
          </div>
          
          <div class="hidden sm:block h-4 w-px bg-gray-700"></div>
          
          <!-- Capacity -->
          <div class="flex items-center gap-1.5">
            <i class="ti ti-server text-orange-400 text-base"></i>
            <span class="text-gray-400">Capacity:</span>
            <span class="font-semibold"><span id="capacity-current">0</span>/<span id="capacity-max">0</span></span>
          </div>
          <% } %>
        </div>
      </div>
</i>
      
      <div class="mt-8">
        <div class="flex flex-col gap-4 mb-6">
          <div class="flex items-center gap-3">
            <h2 class="text-xl font-bold">Streaming Status</h2>
            <!-- Auto-refresh indicator -->
            <div id="autoRefreshIndicator" class="flex items-center gap-2 text-xs text-gray-400">
              <i class="ti ti-refresh text-sm"></i>
              <span>Auto-refresh: <span id="refreshInterval">--</span></span>
            </div>
            <!-- Time Format Toggle -->
            <div class="flex items-center gap-2 ml-auto">
              <span class="text-xs text-gray-400">Time Format:</span>
              <button id="timeFormatToggle" onclick="toggleTimeFormat()" 
                class="flex items-center gap-1.5 px-3 py-1.5 bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded-lg transition-colors text-xs">
                <i class="ti ti-clock text-sm"></i>
                <span id="timeFormatLabel">24h</span>
              </button>
            </div>
            <!-- Bulk Actions (Hidden by default) -->
            <div id="bulkActionsContainer" class="hidden flex items-center gap-2">
              <span class="text-sm text-gray-400" id="selectedCount">0 selected</span>
              <button onclick="deleteSelectedStreams()"
                class="flex items-center gap-1 px-3 py-1.5 bg-red-600 hover:bg-red-700 text-white rounded text-sm transition-colors">
                <i class="ti ti-trash text-sm"></i>
                <span>Delete Selected</span>
              </button>
            </div>
          </div>
          <div class="flex flex-col sm:flex-row items-stretch sm:items-center justify-between gap-3">
            <div class="relative w-full sm:w-64">
              <input type="text" placeholder="Search streams..."
                class="w-full bg-dark-700 border border-gray-600 text-white pl-9 pr-4 py-2 rounded-lg focus:outline-none focus:ring-1 focus:ring-primary">
              <i class="ti ti-search absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
            </div>
            <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-3">
              <button onclick="openTemplateSelector()"
                class="w-full sm:w-auto flex items-center justify-center gap-2 bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg transition-colors whitespace-nowrap">
                <i class="ti ti-template"></i>
                <span>My Templates</span>
              </button>
              <button onclick="openNewStreamModal()"
                class="w-full sm:w-auto flex items-center justify-center gap-2 bg-primary hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition-colors whitespace-nowrap">
                <i class="ti ti-plus"></i>
                <span>New Stream</span>
              </button>
              <% if (youtubeConnected && youtubeChannel) { %>
                <div
                  class="w-full sm:w-auto flex items-center gap-3 bg-dark-700 text-white px-4 py-2 rounded-lg border border-gray-600 whitespace-nowrap">
                  <img src="<%= youtubeChannel.avatar %>" alt="YT Avatar" class="w-6 h-6 rounded-full">
                  <span class="text-sm">Connected as <span class="font-semibold">
                      <%= youtubeChannel.title %>
                    </span></span>
                  <a href="/oauth2/disconnect" class="ml-2 text-red-400 hover:text-red-300 text-sm">Disconnect</a>
                </div>
                <% } else { %>
                  <a href="/oauth2/login"
                    class="w-full sm:w-auto flex items-center justify-center gap-2 bg-dark-700 hover:bg-dark-600 text-white px-4 py-2 rounded-lg border border-gray-600 transition-colors whitespace-nowrap">
                    <i class="ti ti-brand-youtube text-red-500"></i>
                    <span>Connect YouTube</span>
                  </a>
                  <% } %>
            </div>
          </div>
        </div>
      </div>
      <div class="block md:hidden space-y-4">
      </div>
      <div class="hidden md:block bg-gray-800 rounded-lg shadow-md overflow-hidden">
        <div class="overflow-x-auto">
          <table class="min-w-full">
            <thead class="bg-gray-700 sticky top-0 z-9">
              <tr>
                <th class="px-4 py-3 text-left">
                  <input type="checkbox" id="selectAllStreams" onchange="toggleSelectAll(this)"
                    class="w-4 h-4 rounded border-gray-600 text-primary focus:ring-primary focus:ring-offset-0 bg-dark-700 cursor-pointer">
                </th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Stream Name
                </th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Platform
                </th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Schedule
                </th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Start Time
                </th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">End Time
                </th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Status</th>
                <th class="px-6 py-3 text-right text-xs font-medium text-gray-300 uppercase tracking-wider">Actions
                </th>
              </tr>
            </thead>
            <tbody class="divide-y divide-gray-700">
              <tr id="empty-state" class="hover:bg-dark-700/50 transition-colors" style="display: none;">
                <td colspan="7" class="px-6 py-10 text-center">
                  <div class="flex flex-col items-center">
                    <div class="w-16 h-16 rounded-full bg-dark-700 flex items-center justify-center mb-4">
                      <i class="ti ti-broadcast text-gray-500 text-2xl"></i>
                    </div>
                    <p class="text-gray-400 font-medium mb-2">No streams found</p>
                    <p class="text-gray-500 max-w-sm mb-4">Create your first stream to start broadcasting to your
                      audience
                    </p>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      </div>
      <div id="newStreamModal" class="fixed inset-0 bg-black/50 z-50 hidden modal-overlay flex items-center justify-center p-2 md:p-4">
          <div class="bg-dark-800 rounded-lg shadow-xl w-full max-w-2xl modal-container max-h-[95vh] md:max-h-[92vh] flex flex-col relative">
            <div class="flex-shrink-0 flex items-center justify-between px-4 py-3 border-b border-gray-700 bg-dark-800 z-10 rounded-t-lg">
              <h3 class="text-base font-semibold">Create New Stream</h3>
              <div class="flex items-center gap-2">
                <button type="button" onclick="saveAsTemplate()"
                  class="flex items-center gap-1 px-2 py-1 bg-green-500/20 hover:bg-green-500/30 text-green-400 border border-green-500/50 rounded text-xs transition-colors"
                  title="Save as Template">
                  <i class="ti ti-device-floppy text-sm"></i>
                  <span class="hidden sm:inline">Save</span>
                </button>
                <button type="button" onclick="openImportTemplate()"
                  class="flex items-center gap-1 px-2 py-1 bg-purple-500/20 hover:bg-purple-500/30 text-purple-400 border border-purple-500/50 rounded text-xs transition-colors"
                  title="Import Template">
                  <i class="ti ti-upload text-sm"></i>
                  <span class="hidden sm:inline">Import</span>
                </button>
                <button onclick="closeNewStreamModal()" class="text-gray-400 hover:text-white transition-colors ml-1">
                  <i class="ti ti-x text-xl"></i>
                </button>
              </div>
            </div>
            
            <!-- Tab Switcher -->
            <div class="flex items-center gap-2 px-4 py-2 bg-dark-900 border-b border-gray-700">
              <button type="button" id="tabManual" onclick="switchStreamTab('manual')"
                class="flex-1 px-4 py-2 text-sm font-medium rounded transition-colors bg-primary text-white">
                <i class="ti ti-broadcast mr-1.5"></i>Manual RTMP
              </button>
              <button type="button" id="tabYouTube" onclick="switchStreamTab('youtube')"
                class="flex-1 px-4 py-2 text-sm font-medium rounded transition-colors text-gray-400 hover:text-white hover:bg-dark-700">
                <i class="ti ti-brand-youtube mr-1.5"></i>YouTube API
              </button>
            </div>
            

            
            <div class="flex-1 overflow-y-auto">
              <form id="newStreamForm" class="px-4 pt-3 pb-3 space-y-3">
                <input type="hidden" id="selectedVideoId" name="videoId" value="">

                <!-- Form Fields (Single Column) -->
                <div class="space-y-3">
                  <div class="relative">
                    <label class="text-sm font-medium text-white block mb-2">Select Video</label>
                    <div class="relative">
                      <button type="button" onclick="toggleVideoSelector()"
                        class="w-full flex items-center justify-between px-4 py-2.5 bg-dark-700 border border-gray-600 rounded-lg hover:border-primary focus:border-primary focus:ring-1 focus:ring-primary transition-colors text-left">
                        <span class="text-sm text-gray-300" id="selectedVideo">Choose a video...</span>
                        <i class="ti ti-chevron-down text-gray-400"></i>
                      </button>
                      <div id="videoSelectorDropdown"
                        class="hidden absolute z-10 mt-2 w-full bg-dark-700 rounded-lg border border-gray-600 shadow-lg">
                        <div class="p-2 border-b border-gray-600/50">
                          <div class="relative">
                            <input type="text" id="videoSearchInput"
                              class="w-full bg-dark-800 text-white pl-8 pr-4 py-2 rounded-lg text-sm focus:outline-none focus:ring-1 focus:ring-primary border border-gray-700"
                              placeholder="Search videos...">
                            <i class="ti ti-search absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                          </div>
                        </div>
                        <div id="videoListContainer" class="p-2 space-y-1 max-h-60 overflow-y-auto">
                        </div>
                      </div>
                    </div>
                  </div>

                  <div>
                    <label class="text-sm font-medium text-white block mb-2">Stream Title</label>
                    <input type="text"
                      class="w-full px-4 py-2.5 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary"
                      placeholder="Enter stream title..." name="streamTitle" id="streamTitle" required>
                  </div>
                  
                  <!-- YouTube API Fields (Hidden by default) -->
                  <div id="youtubeApiFields" class="hidden space-y-3">
                    
                    <!-- Note: Select Video & Stream Title sudah ada di atas (shared fields) -->
                    
                    <!-- Description -->
                    <div>
                      <label class="text-sm font-medium text-white block mb-2">Description</label>
                      <textarea name="youtubeDescription" id="youtubeDescription" rows="3"
                        class="w-full px-4 py-2.5 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary"
                        placeholder="Stream description (optional)"></textarea>
                    </div>
                    
                    <!-- RTMP URL -->
                    <div>
                      <label class="text-sm font-medium text-white block mb-2">RTMP Server URL</label>
                      <div class="relative">
                        <input type="text" id="youtubeRtmpUrl" readonly
                          class="w-full px-4 py-2.5 pl-10 pr-4 bg-dark-800 border border-gray-600 rounded-lg text-gray-400 cursor-not-allowed"
                          placeholder="Will be auto-filled from stream key"
                          value="">
                        <i class="ti ti-link text-gray-500 absolute left-3 top-1/2 -translate-y-1/2"></i>
                      </div>
                    </div>
                    
                    <!-- Stream Key with Load Button -->
                    <div>
                      <label class="text-sm font-medium text-white block mb-2">Stream Key</label>
                      <div class="flex gap-2">
                        <div class="relative flex-1">
                          <input type="password" id="youtubeStreamKey" readonly
                            class="w-full px-4 py-2.5 pl-10 pr-12 bg-dark-800 border border-gray-600 rounded-lg text-gray-400 cursor-not-allowed font-mono text-sm"
                            placeholder="Will be auto-filled from stream key"
                            value="">
                          <i class="ti ti-key text-gray-500 absolute left-3 top-1/2 -translate-y-1/2"></i>
                          <button type="button" onclick="toggleYouTubeStreamKeyVisibility()"
                            class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-white transition-colors">
                            <i class="ti ti-eye" id="youtubeStreamKeyToggle"></i>
                          </button>
                        </div>
                        <button type="button" onclick="toggleYouTubeStreamKeysDropdown()"
                          class="flex items-center gap-2 px-4 py-2.5 bg-primary hover:bg-blue-600 text-white rounded-lg transition-colors whitespace-nowrap">
                          <i class="ti ti-download text-sm"></i>
                          <span>Load</span>
                        </button>
                      </div>
                      
                      <!-- Dropdown for Stream Keys -->
                      <div id="youtubeStreamKeysDropdown" class="hidden mt-2 bg-dark-700 border border-gray-600 rounded-lg shadow-lg max-h-60 overflow-y-auto">
                        <div class="p-2">
                          <div class="flex items-center justify-between mb-2 px-2">
                            <span class="text-xs font-medium text-gray-400">Select from your channel:</span>
                            <button type="button" onclick="toggleYouTubeStreamKeysDropdown()"
                              class="text-gray-400 hover:text-white">
                              <i class="ti ti-x text-sm"></i>
                            </button>
                          </div>
                          <div id="youtubeStreamKeysList" class="space-y-1">
                            <div class="text-center py-4 text-gray-400">
                              <i class="ti ti-loader animate-spin text-xl mb-2"></i>
                              <p class="text-xs">Loading...</p>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    <!-- Collapsible Additional Settings -->
                    <div class="border-t border-gray-700 pt-3">
                      <button type="button" onclick="toggleYouTubeAdditionalSettings()"
                        class="flex items-center justify-between w-full px-2 py-2 hover:bg-dark-700/30 rounded transition-colors">
                        <span class="text-sm font-medium text-white">
                          <i class="ti ti-settings mr-1.5"></i>Additional Settings (Optional)
                        </span>
                        <i class="ti ti-chevron-down text-gray-400 transition-transform duration-200" id="youtubeAdditionalSettingsIcon"></i>
                      </button>
                      
                      <div id="youtubeAdditionalSettings" class="hidden mt-3 space-y-3">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                          <div>
                            <label class="text-sm font-medium text-white block mb-2">Privacy</label>
                            <select name="youtubePrivacy" id="youtubePrivacy"
                              class="w-full px-4 py-2.5 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary text-sm">
                              <option value="public">Public</option>
                              <option value="unlisted" selected>Unlisted</option>
                              <option value="private">Private</option>
                            </select>
                          </div>
                          
                          <div>
                            <label class="text-sm font-medium text-white block mb-2">Thumbnail</label>
                            <input type="file" name="youtubeThumbnail" id="youtubeThumbnail" accept="image/*"
                              class="w-full px-4 py-2.5 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary file:mr-4 file:py-2 file:px-4 file:border-0 file:text-sm file:bg-dark-600 file:text-gray-200 file:rounded text-sm">
                          </div>
                        </div>
                        
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                          <div>
                            <label class="text-sm font-medium text-white block mb-2">Made for Kids</label>
                            <div class="flex items-center gap-4 pt-2">
                              <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                                <input type="radio" name="youtubeMadeForKids" value="yes" class="w-4 h-4">
                                <span>Yes</span>
                              </label>
                              <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                                <input type="radio" name="youtubeMadeForKids" value="no" checked class="w-4 h-4">
                                <span>No</span>
                              </label>
                            </div>
                          </div>
                          
                          <div>
                            <label class="text-sm font-medium text-white block mb-2">Age Restriction</label>
                            <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer pt-2">
                              <input type="checkbox" name="youtubeAgeRestricted" id="youtubeAgeRestricted" class="w-4 h-4 rounded">
                              <span>Age-restricted (18+)</span>
                            </label>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <div id="manualRtmpFields" class="space-y-3">
                    <label class="text-sm font-medium text-white block mb-1.5">Stream Configuration</label>
                    <div class="space-y-2">
                      <div class="relative">
                        <input type="text" id="rtmpUrl" name="rtmpUrl"
                          class="w-full pl-10 pr-12 py-2.5 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary"
                          placeholder="RTMP URL" required>
                        <i class="ti ti-link absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                        <button type="button" id="platformSelector"
                          class="absolute right-2 top-1/2 -translate-y-1/2 w-8 h-8 flex items-center justify-center rounded-full hover:bg-dark-600 transition-colors"
                          aria-label="Select platform">
                          <i class="ti ti-list-check text-gray-400 hover:text-primary"></i>
                        </button>
                        <div id="platformDropdown"
                          class="hidden absolute z-10 right-0 mt-1 w-48 bg-dark-700 rounded-lg border border-gray-600 shadow-lg overflow-hidden">
                          <div class="py-1">
                            <button type="button"
                              class="platform-option w-full flex items-center px-4 py-2 hover:bg-dark-600"
                              data-url="rtmps://a.rtmp.youtube.com/live2">
                              <i class="ti ti-brand-youtube text-red-500 text-base mr-2"></i>
                              <span class="text-sm">YouTube</span>
                            </button>
                            <button type="button"
                              class="platform-option w-full flex items-center px-4 py-2 hover:bg-dark-600"
                              data-url="rtmps://live-api-s.facebook.com:443/rtmp">
                              <i class="ti ti-brand-facebook text-blue-500 text-base mr-2"></i>
                              <span class="text-sm">Facebook</span>
                            </button>
                            <button type="button"
                              class="platform-option w-full flex items-center px-4 py-2 hover:bg-dark-600"
                              data-url="rtmps://ingest.global.live.prod.tiktok.com/live">
                              <i class="ti ti-brand-tiktok text-black text-base mr-2"></i>
                              <span class="text-sm">TikTok</span>
                            </button>
                            <button type="button"
                              class="platform-option w-full flex items-center px-4 py-2 hover:bg-dark-600"
                              data-url="rtmps://live.shopee.co.id/live">
                              <i class="ti ti-brand-shopee text-orange-500 text-base mr-2"></i>
                              <span class="text-sm">Shopee Live</span>
                            </button>
                            <button type="button"
                              class="platform-option w-full flex items-center px-4 py-2 hover:bg-dark-600"
                              data-url="rtmps://live.twitch.tv/live">
                              <i class="ti ti-brand-twitch text-purple-500 text-base mr-2"></i>
                              <span class="text-sm">Twitch</span>
                            </button>
                          </div>
                        </div>
                      </div>
                      <div class="relative">
                        <input type="password" id="streamKey" name="streamKey"
                          class="w-full pl-10 pr-12 py-2.5 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary"
                          placeholder="Stream Key" required>
                        <i class="ti ti-key absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                        <button type="button" onclick="toggleStreamKeyVisibility()"
                          class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-white transition-colors">
                          <i class="ti ti-eye" id="streamKeyToggle"></i>
                        </button>
                      </div>
                    </div>
                  </div>
                  <!-- End Manual RTMP Fields -->
                </div>
                
                <!-- Schedule Settings -->
                <div class="pt-3 border-t border-gray-700">
                  <div class="space-y-3">
                    <div class="flex items-center justify-between px-2">
                      <label class="text-sm font-medium text-white">Schedule Settings</label>
                      <button type="button" onclick="addScheduleSlot()"
                        class="flex items-center gap-1.5 px-3 py-1.5 bg-primary hover:bg-blue-600 text-white rounded-lg text-xs transition-colors">
                        <i class="ti ti-plus text-sm"></i>
                        <span>Add</span>
                      </button>
                    </div>
                    <div class="flex items-center justify-between text-xs bg-dark-700/30 rounded-lg px-3 py-2.5">
                      <span id="serverTimeDisplay" class="text-gray-400">Server time: loading...</span>
                      <label class="flex items-center gap-2.5 cursor-pointer">
                        <span class="text-gray-300">Loop Video</span>
                        <div class="relative inline-flex items-center">
                          <input type="checkbox" name="loopVideo" id="loopVideo" class="sr-only peer" checked>
                          <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-checked:bg-primary transition-colors"></div>
                          <div class="absolute left-[3px] top-[3px] w-5 h-5 bg-white rounded-full transition-all peer-checked:translate-x-5 shadow-md"></div>
                        </div>
                      </label>
                    </div>
                  
                  <div id="scheduleSlotsContainer" class="space-y-3 mt-3">
                    <!-- Default first schedule slot -->
                    <div class="schedule-slot p-3 bg-dark-700/50 rounded-lg border border-gray-600">
                      <!-- Time & Duration Row - Responsive Grid -->
                      <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 mb-3">
                        <!-- Start Time -->
                        <div>
                          <label class="text-xs text-gray-400 mb-1 block">Start</label>
                          <input type="time"
                            class="schedule-time w-full h-[36px] px-2 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary text-xs [color-scheme:dark]"
                            onchange="calculateDurationFromEndTime(this)">
                        </div>

                        <!-- End Time -->
                        <div>
                          <label class="text-xs text-gray-400 mb-1 block">End</label>
                          <input type="time"
                            class="schedule-endtime w-full h-[36px] px-2 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary text-xs [color-scheme:dark]"
                            onchange="calculateDurationFromEndTime(this)">
                        </div>

                        <!-- Duration Input (Hours & Minutes) -->
                        <div>
                          <label class="text-xs text-gray-400 mb-1 block">Duration</label>
                          <div class="flex gap-1">
                            <input type="number" min="0" max="23" value="1"
                              class="duration-hours w-full h-[36px] px-1 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary text-xs text-center"
                              placeholder="H" onchange="calculateFromDuration(this)">
                            <span class="text-xs text-gray-400 flex items-center">:</span>
                            <input type="number" min="0" max="59" value="0"
                              class="duration-minutes w-full h-[36px] px-1 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary text-xs text-center"
                              placeholder="M" onchange="calculateFromDuration(this)">
                          </div>
                          <input type="hidden" class="schedule-duration" value="60">
                        </div>

                        <!-- Delete Button -->
                        <div>
                          <label class="text-xs text-gray-400 mb-1 block opacity-0">Del</label>
                          <button type="button" onclick="removeScheduleSlot(this)"
                            class="w-full h-[36px] flex items-center justify-center bg-red-500/20 hover:bg-red-500/30 text-red-500 border border-red-500/50 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                            <i class="ti ti-trash text-sm"></i>
                          </button>
                        </div>
                      </div>

                      <!-- Recurring Days - Single Row -->
                      <div class="space-y-2">
                        <div class="flex items-center justify-between">
                          <label class="text-xs text-gray-400">Recurring Days:</label>
                          <button type="button" onclick="selectAllDays(this)" class="px-2 py-1 text-xs bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors">
                            All Days
                          </button>
                        </div>
                        <div class="flex gap-1 flex-wrap">
                          <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="0">Sun</button>
                          <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="1">Mon</button>
                          <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="2">Tue</button>
                          <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="3">Wed</button>
                          <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="4">Thu</button>
                          <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="5">Fri</button>
                          <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="6">Sat</button>
                        </div>
                      </div>
                    </div>
                  </div>

                    <div class="text-xs text-gray-400 flex items-center gap-1 px-2">
                      <i class="ti ti-info-circle"></i>
                      <span>You can add multiple schedules for different time slots in a day. Leave empty to stream immediately.</span>
                    </div>
                  </div>
                </div>
                <!-- End of schedule settings -->
              </form>
            </div>
            
            <!-- Modal Footer -->
            <div class="flex-shrink-0 px-4 py-3 border-t border-gray-700 bg-dark-800 rounded-b-lg">
              <div class="grid grid-cols-2 gap-3">
                <button type="button" onclick="closeNewStreamModal()"
                  class="px-4 py-2.5 text-sm font-medium bg-dark-700 hover:bg-dark-600 text-gray-300 hover:text-white border border-gray-600 rounded-lg transition-colors">
                  Cancel
                </button>
                <button type="submit" form="newStreamForm"
                  class="px-4 py-2.5 text-sm font-medium bg-primary hover:bg-blue-600 text-white rounded-lg transition-colors">
                  Create Stream
                </button>
              </div>
            </div>
            
            <!-- Scroll to Top Button -->
            <button type="button" id="scrollToTopBtn" onclick="scrollModalToTop('newStreamModal')"
              class="hidden absolute bottom-20 right-4 md:right-6 w-11 h-11 bg-primary hover:bg-blue-600 active:bg-blue-700 text-white rounded-full shadow-lg hover:shadow-xl transition-all duration-300 z-20 items-center justify-center"
              title="Scroll to top">
              <i class="ti ti-arrow-up text-lg"></i>
            </button>
          </div><!-- Close modal-container -->
      </div><!-- Close newStreamModal -->
      <div id="editStreamModal" class="fixed inset-0 bg-black/50 z-50 hidden modal-overlay flex items-center justify-center p-2 md:p-4">
          <div class="bg-dark-800 rounded-lg shadow-xl w-full max-w-2xl modal-container flex flex-col max-h-[95vh] md:max-h-[92vh] relative">
            <div class="flex-shrink-0 flex items-center justify-between px-4 py-3 border-b border-gray-700 bg-dark-800 z-10 rounded-t-lg">
              <h3 class="text-base font-semibold">Edit Stream</h3>
              <button onclick="closeEditStreamModal()" class="text-gray-400 hover:text-white transition-colors">
                <i class="ti ti-x text-xl"></i>
              </button>
            </div>
            <div class="flex-1 overflow-y-auto">
              <form id="editStreamForm" class="px-4 pt-3 pb-3 space-y-3"></form>
                <input type="hidden" id="editStreamId" name="streamId" value="">
                <input type="hidden" id="editSelectedVideoId" name="videoId" value="">

                <!-- Form Fields (Single Column) -->
                <div class="space-y-3">
                  <div class="relative">
                    <label class="text-sm font-medium text-white block mb-2">Select Video</label>
                    <div class="relative">
                      <button type="button" onclick="toggleEditVideoSelector()"
                        class="w-full flex items-center justify-between px-4 py-2.5 bg-dark-700 border border-gray-600 rounded-lg hover:border-primary focus:border-primary focus:ring-1 focus:ring-primary transition-colors text-left">
                        <span class="text-sm text-gray-300" id="editSelectedVideo">Choose a video...</span>
                        <i class="ti ti-chevron-down text-gray-400"></i>
                      </button>
                      <div id="editVideoSelectorDropdown"
                        class="hidden absolute z-10 mt-2 w-full bg-dark-700 rounded-lg border border-gray-600 shadow-lg">
                        <div class="p-2 border-b border-gray-600/50">
                          <div class="relative">
                            <input type="text" id="editVideoSearchInput"
                              class="w-full bg-dark-800 text-white pl-8 pr-4 py-2 rounded-lg text-sm focus:outline-none focus:ring-1 focus:ring-primary border border-gray-700"
                              placeholder="Search videos...">
                            <i class="ti ti-search absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                          </div>
                        </div>
                        <div id="editVideoListContainer" class="p-2 space-y-1 max-h-60 overflow-y-auto">
                        </div>
                      </div>
                    </div>
                  </div>

                  <div>
                    <label class="text-sm font-medium text-white block mb-2">Stream Title</label>
                    <input type="text"
                      class="w-full px-4 py-2.5 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary"
                      placeholder="Enter stream title..." name="streamTitle" id="editStreamTitle" required>
                  </div>
                  <div class="space-y-4">
                    <label class="text-sm font-medium text-white block mb-3">Stream Configuration</label>
                    <div class="space-y-3">
                      <div class="relative">
                        <input type="text" id="editRtmpUrl" name="rtmpUrl"
                          class="w-full pl-10 pr-12 py-2.5 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary"
                          placeholder="RTMP URL" required>
                        <i class="ti ti-link absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                        <button type="button" id="editPlatformSelector"
                          class="absolute right-2 top-1/2 -translate-y-1/2 w-8 h-8 flex items-center justify-center rounded-full hover:bg-dark-600 transition-colors"
                          aria-label="Select platform">
                          <i class="ti ti-list-check text-gray-400 hover:text-primary"></i>
                        </button>
                        <div id="editPlatformDropdown"
                          class="hidden absolute z-10 right-0 mt-1 w-48 bg-dark-700 rounded-lg border border-gray-600 shadow-lg overflow-hidden">
                          <div class="py-1">
                            <button type="button"
                              class="platform-option w-full flex items-center px-4 py-2 hover:bg-dark-600"
                              data-url="rtmps://a.rtmp.youtube.com/live2">
                              <i class="ti ti-brand-youtube text-red-500 text-base mr-2"></i>
                              <span class="text-sm">YouTube</span>
                            </button>
                            <button type="button"
                              class="platform-option w-full flex items-center px-4 py-2 hover:bg-dark-600"
                              data-url="rtmps://live-api-s.facebook.com:443/rtmp">
                              <i class="ti ti-brand-facebook text-blue-500 text-base mr-2"></i>
                              <span class="text-sm">Facebook</span>
                            </button>
                            <button type="button"
                              class="platform-option w-full flex items-center px-4 py-2 hover:bg-dark-600"
                              data-url="rtmps://ingest.global.live.prod.tiktok.com/live">
                              <i class="ti ti-brand-tiktok text-black text-base mr-2"></i>
                              <span class="text-sm">TikTok</span>
                            </button>
                            <button type="button"
                              class="platform-option w-full flex items-center px-4 py-2 hover:bg-dark-600"
                              data-url="rtmps://live.shopee.co.id/live">
                              <i class="ti ti-brand-shopee text-orange-500 text-base mr-2"></i>
                              <span class="text-sm">Shopee Live</span>
                            </button>
                            <button type="button"
                              class="platform-option w-full flex items-center px-4 py-2 hover:bg-dark-600"
                              data-url="rtmps://live.twitch.tv/live">
                              <i class="ti ti-brand-twitch text-purple-500 text-base mr-2"></i>
                              <span class="text-sm">Twitch</span>
                            </button>
                          </div>
                        </div>
                      </div>
                      <div class="relative">
                        <input type="password" id="editStreamKey" name="streamKey"
                          class="w-full pl-10 pr-12 py-2.5 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary"
                          placeholder="Stream Key" required>
                        <i class="ti ti-key absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                        <button type="button" onclick="toggleEditStreamKeyVisibility()"
                          class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-white transition-colors">
                          <i class="ti ti-eye" id="editStreamKeyToggle"></i>
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="space-y-2 pt-2 border-t border-gray-700">
                  <div class="flex flex-col gap-2">
                    <div class="flex items-center justify-between px-2">
                      <label class="text-sm font-medium text-white">Schedule Settings</label>
                      <button type="button" onclick="addEditScheduleSlot()"
                        class="flex items-center gap-1.5 px-3 py-1.5 bg-primary hover:bg-blue-600 text-white rounded-lg text-xs transition-colors">
                        <i class="ti ti-plus text-sm"></i>
                        <span>Add</span>
                      </button>
                    </div>
                    <div class="flex items-center justify-between text-xs bg-dark-700/30 rounded-lg px-3 py-2.5">
                      <span id="editServerTimeDisplay" class="text-gray-400">Server time: loading...</span>
                      <label class="flex items-center gap-2.5 cursor-pointer">
                        <span class="text-gray-300">Loop Video</span>
                        <div class="relative inline-flex items-center">
                          <input type="checkbox" name="loopVideo" id="editLoopVideo" class="sr-only peer" checked>
                          <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-checked:bg-primary transition-colors"></div>
                          <div class="absolute left-[3px] top-[3px] w-5 h-5 bg-white rounded-full transition-all peer-checked:translate-x-5 shadow-md"></div>
                        </div>
                      </label>
                    </div>
                  </div>

                  <div id="editScheduleSlotsContainer" class="space-y-3 mt-3">
                    <!-- Schedule slots will be loaded here -->
                  </div>
                </div>
              </form>
            </div>
            
            <!-- Modal Footer -->
            <div class="flex-shrink-0 px-4 py-3 border-t border-gray-700 bg-dark-800 rounded-b-lg"></div>
              <div class="grid grid-cols-2 gap-3">
                <button type="button" onclick="closeEditStreamModal()"
                  class="w-full px-4 py-2.5 text-sm font-medium bg-dark-700 hover:bg-dark-600 text-gray-300 hover:text-white border border-gray-600 rounded-lg transition-colors">
                  Cancel
                </button>
                <button type="submit" form="editStreamForm"
                  class="w-full px-4 py-2.5 text-sm font-medium bg-primary hover:bg-blue-600 text-white rounded-lg transition-colors">
                  Save Changes
                </button>
              </div>
            </div>
            
            <!-- Scroll to Top Button for Edit Modal -->
            <button type="button" id="scrollToTopBtnEdit" onclick="scrollModalToTop('editStreamModal')"
              class="hidden absolute bottom-20 right-4 md:right-6 w-11 h-11 bg-primary hover:bg-blue-600 active:bg-blue-700 text-white rounded-full shadow-lg hover:shadow-xl transition-all duration-300 z-20 items-center justify-center"
              title="Scroll to top">
              <i class="ti ti-arrow-up text-lg"></i>
            </button>
          </div><!-- Close modal-container -->
      </div><!-- Close editStreamModal -->
      <style>
        .video-js {
          background-color: #1f2937;
          width: 100%;
          height: 100%;
        }

        .video-js .vjs-big-play-button {
          background-color: rgba(59, 130, 246, 0.7);
          border-color: rgba(59, 130, 246, 0.7);
          border-radius: 50%;
          width: 60px;
          height: 60px;
          line-height: 60px;
          left: 50%;
          top: 50%;
          margin-left: -30px;
          margin-top: -30px;
        }

        .video-js:hover .vjs-big-play-button {
          background-color: rgb(59, 130, 246);
        }

        .video-js .vjs-control-bar {
          background-color: rgba(31, 41, 55, 0.7);
        }

        .video-js .vjs-slider {
          background-color: rgba(255, 255, 255, 0.2);
        }

        .video-js .vjs-play-progress,
        .video-js .vjs-volume-level {
          background-color: rgb(59, 130, 246);
        }

        .video-js .vjs-load-progress {
          background: rgba(255, 255, 255, 0.3);
        }

        .aspect-video .video-js {
          aspect-ratio: 16/9;
          height: auto !important;
        }

        .video-js .vjs-control-bar {
          display: flex !important;
          visibility: visible !important;
          opacity: 1 !important;
          transition: visibility 0.1s, opacity 0.1s !important;
        }

        .video-js.vjs-user-inactive:not(.vjs-paused) .vjs-control-bar {
          visibility: visible !important;
          opacity: 0.7 !important;
        }

        .video-js .vjs-progress-control {
          min-width: 4em !important;
          flex: 1 !important;
        }

        .video-js .vjs-progress-control .vjs-progress-holder {
          margin: 0 10px !important;
          height: 0.3em !important;
        }

        .video-js .vjs-progress-control:hover .vjs-progress-holder {
          height: 0.5em !important;
        }

        .vjs-icon-placeholder:before {
          position: absolute !important;
          top: 50% !important;
          left: 50% !important;
          transform: translate(-50%, -50%) !important;
        }

        #videoListContainer {
          scrollbar-width: thin;
          scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
        }

        #videoListContainer::-webkit-scrollbar {
          width: 6px;
        }

        #videoListContainer::-webkit-scrollbar-track {
          background: transparent;
        }

        #videoListContainer::-webkit-scrollbar-thumb {
          background-color: rgba(156, 163, 175, 0.3);
          border-radius: 20px;
        }

        #videoSearchInput::placeholder {
          color: rgba(156, 163, 175, 0.7);
        }

        .highlight {
          background-color: rgba(59, 130, 246, 0.2);
          padding: 0 2px;
          border-radius: 2px;
        }

        #platformDropdown {
          transform-origin: top right;
          transition: transform 0.2s, opacity 0.2s;
          transform: scale(0.95);
          opacity: 0;
        }

        #platformDropdown:not(.hidden) {
          transform: scale(1);
          opacity: 1;
        }

        .platform-option:hover i {
          transform: scale(1.1);
        }

        .platform-option i {
          transition: transform 0.2s;
        }

        #platformSelector {
          display: flex;
          align-items: center;
          justify-content: center;
        }

        #platformSelector i {
          display: flex;
          align-items: center;
          justify-content: center;
          width: 100%;
          height: 100%;
          font-size: 1.25rem;
          line-height: 1;
        }

        #platformDropdown {
          transform-origin: top right;
          transition: transform 0.2s, opacity 0.2s;
          transform: scale(0.95);
          opacity: 0;
        }

        #platformDropdown:not(.hidden) {
          transform: scale(1);
          opacity: 1;
        }

        * {
          scrollbar-width: thin;
          scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
        }

        ::-webkit-scrollbar {
          width: 5px;
          height: 5px;
        }

        ::-webkit-scrollbar-track {
          background: transparent;
        }

        ::-webkit-scrollbar-thumb {
          background-color: rgba(156, 163, 175, 0.3);
          border-radius: 20px;
        }

        ::-webkit-scrollbar-thumb:hover {
          background-color: rgba(156, 163, 175, 0.5);
        }

        .modal-overlay,
        .overflow-y-auto,
        .overflow-x-auto {
          scrollbar-width: thin;
          scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
        }

        .modal-overlay::-webkit-scrollbar,
        .overflow-y-auto::-webkit-scrollbar,
        .overflow-x-auto::-webkit-scrollbar {
          width: 5px;
          height: 5px;
        }

        .bg-dark-800::-webkit-scrollbar-thumb {
          background-color: rgba(156, 163, 175, 0.2);
        }

        .group:hover .group-hover\:block {
          display: block;
        }

        .group .group-hover\:block {
          transition-delay: 200ms;
        }

        .group:hover .group-hover\:block {
          animation: fadeIn 0.2s;
        }

        @keyframes fadeIn {
          from {
            opacity: 0;
            transform: translate(-50%, 5px);
          }

          to {
            opacity: 1;
            transform: translate(-50%, 0);
          }
        }
      </style>
      <script>
        function formatMemory(value) {
          if (!value) return '0 MB';
          // If already formatted string, return as is
          if (typeof value === 'string') return value;
          // If number, format it
          if (typeof value === 'number') {
            if (value >= 1024) {
              return (value / 1024).toFixed(1) + ' GB';
            }
            return value.toFixed(0) + ' MB';
          }
          return '0 MB';
        }

        function fetchPlaylistInfo(playlistId, streamId) {
          fetch(`/api/playlists/${playlistId}`)
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                const playlist = data.playlist;
                const videoCount = playlist.videos ? playlist.videos.length : 0;
                const playbackMode = playlist.is_shuffle ? 'Shuffle' : 'Sequential';
                const playlistMetadata = `Playlist • ${videoCount} videos • ${playbackMode}`;

                const streamCards = document.querySelectorAll(`[data-stream-id="${streamId}"]`);
                streamCards.forEach(card => {
                  const metadataElement = card.querySelector('.text-gray-400');
                  if (metadataElement && metadataElement.textContent.includes('Playlist • Loading...')) {
                    metadataElement.textContent = playlistMetadata;
                  }
                });

                const tableRows = document.querySelectorAll(`tr[data-stream-id="${streamId}"]`);
                tableRows.forEach(row => {
                  const metadataCell = row.querySelector('td:nth-child(4)');
                  if (metadataCell && metadataCell.textContent.includes('Playlist • Loading...')) {
                    metadataCell.textContent = playlistMetadata;
                  }
                });
              }
            })
            .catch(error => {
              console.error('Error fetching playlist info:', error);
              const streamCards = document.querySelectorAll(`[data-stream-id="${streamId}"]`);
              streamCards.forEach(card => {
                const metadataElement = card.querySelector('.text-gray-400');
                if (metadataElement && metadataElement.textContent.includes('Playlist • Loading...')) {
                  metadataElement.textContent = 'Playlist • Error loading info';
                }
              });
            });
        }

        function updateSystemStats() {
          fetch('/api/system-stats')
            .then(response => response.json())
            .then(data => {
              // Compact Indicators - CPU
              const cpuUsage = document.getElementById('cpu-usage');
              if (cpuUsage) cpuUsage.textContent = data.cpu.usage;

              // Memory - show Used / Total format
              const memoryUsed = document.getElementById('memory-used');
              const memoryTotal = document.getElementById('memory-total');
              
              if (memoryUsed && data.memory.used) {
                // Extract number from "119.45 MB" format
                const usedMatch = data.memory.used.match(/[\d.]+/);
                memoryUsed.textContent = usedMatch ? parseFloat(usedMatch[0]).toFixed(0) : '0';
              }
              
              if (memoryTotal && data.memory.total) {
                // Extract number from "4096.00 MB" format
                const totalMatch = data.memory.total.match(/[\d.]+/);
                const totalValue = totalMatch ? parseFloat(totalMatch[0]) : 0;
                
                // Check if it's in GB
                if (data.memory.total.includes('GB')) {
                  memoryTotal.textContent = (totalValue * 1024).toFixed(0);
                } else {
                  memoryTotal.textContent = totalValue.toFixed(0);
                }
              }

              // Active Streams counter
              const activeStreams = document.getElementById('active-streams');
              if (activeStreams) activeStreams.textContent = data.activeStreams || 0;

              // Network stats
              if (data.network) {
                const uploadSpeed = document.getElementById('upload-speed');
                const downloadSpeed = document.getElementById('download-speed');
                
                if (uploadSpeed) uploadSpeed.textContent = data.network.uploadFormatted;
                if (downloadSpeed) downloadSpeed.textContent = data.network.downloadFormatted;
              }
              
              // Disk stats (admin only)
              if (data.disk) {
                const diskUsed = document.getElementById('disk-used');
                const diskTotal = document.getElementById('disk-total');
                
                if (diskUsed) diskUsed.textContent = data.disk.used;
                if (diskTotal) diskTotal.textContent = data.disk.total;
              }
              
              // Update capacity info (admin only)
              if (data.capacity) {
                const capacityCurrent = document.getElementById('capacity-current');
                const capacityMax = document.getElementById('capacity-max');
                
                if (capacityCurrent) capacityCurrent.textContent = data.capacity.current || 0;
                if (capacityMax) capacityMax.textContent = data.capacity.max || 0;
              }
            })
            .catch(error => console.error('Error fetching system stats:', error));
        }



        updateSystemStats();
        setInterval(updateSystemStats, 5000);
        document.getElementById('newStreamForm').addEventListener('submit', function (e) {
          e.preventDefault();
          const videoId = document.getElementById('selectedVideoId').value;
          if (!videoId) {
            showNotification('Warning', 'Please select a video before creating the stream', 'warning');
            const videoSelector = document.querySelector('[onclick="toggleVideoSelector()"]');
            videoSelector.classList.add('border-red-500');
            videoSelector.classList.remove('border-gray-600');
            videoSelector.animate([
              { transform: 'translateX(0px)' },
              { transform: 'translateX(-5px)' },
              { transform: 'translateX(5px)' },
              { transform: 'translateX(-5px)' },
              { transform: 'translateX(0px)' }
            ], {
              duration: 300,
              iterations: 1
            });
            return;
          }
          if (!isStreamKeyValid) {
            showNotification('Warning', 'Please use a different stream key. This one is already in use.', 'warning');
            return;
          }
          const formData = {
            streamTitle: document.getElementById('streamTitle').value,
            videoId: document.getElementById('selectedVideoId').value,
            rtmpUrl: document.getElementById('rtmpUrl').value,
            streamKey: document.getElementById('streamKey').value,
            bitrate: document.querySelector('select[name="bitrate"]').value,
            fps: document.querySelector('select[name="fps"]').value,
            loopVideo: document.querySelector('input[name="loopVideo"]').checked,
            orientation: currentOrientation,
            resolution: document.getElementById('currentResolution').textContent.split(' ')[0],
            useAdvancedSettings: document.getElementById('advancedSettingsToggle').checked
          };
          // Collect schedules based on stream mode
          if (currentStreamMode === 'schedule') {
            const schedules = collectSchedules();
            if (schedules.length > 0) {
              formData.schedules = schedules;
            }
          } else {
            // Stream Now mode - no schedules, will start immediately
            formData.streamNow = true;
          }
          const csrfToken = document.querySelector('input[name="_csrf"]')?.value;
          fetch('/api/streams', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              ...(csrfToken ? { 'X-CSRF-Token': csrfToken } : {})
            },
            body: JSON.stringify(formData)
          })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                if (data.streamNow) {
                  // Stream Now mode - auto start the stream
                  showNotification('Success!', 'Stream created! Starting stream now...', 'success');
                  closeNewStreamModal();
                  setTimeout(() => {
                    startStream(data.stream.id);
                  }, 500);
                } else {
                  // Schedule mode - just reload
                  showNotification('Success!', 'Stream created successfully!', 'success');
                  closeNewStreamModal();
                  setTimeout(() => {
                    window.location.reload();
                  }, 1000);
                }
              } else {
                showNotification('Error', data.error || 'Failed to create stream', 'error');
              }
            })
            .catch(error => {
              console.error('Error:', error);
              showNotification('Error', 'An error occurred while creating the stream', 'error');
            });
        });
        // Auto-refresh configuration
        let autoRefreshInterval = null;
        let lastRefreshTime = Date.now();
        
        // Move these functions to global scope so loadStreams can access them
        function updateStreamCounters(streams) {
          const liveStreams = streams.filter(stream => stream.status === 'live').length;
          const desktopCounter = document.querySelector('.hidden.md\\:grid .bg-gray-800:nth-child(1) p.text-3xl');
          const mobileCounter = document.querySelector('.grid.grid-cols-2.md\\:hidden .bg-gray-800:nth-child(1) p.text-xl');
          if (desktopCounter) desktopCounter.textContent = liveStreams;
          if (mobileCounter) mobileCounter.textContent = liveStreams;
        }
        
        function showEmptyState() {
          document.querySelectorAll('tbody tr:not(#empty-state)').forEach(el => {
            el.style.display = 'none';
          });
          const emptyState = document.getElementById('empty-state');
          if (emptyState) {
            emptyState.style.display = 'table-row';
          }
          document.querySelectorAll('.block.md\\:hidden.space-y-4 > div').forEach(el => {
            el.style.display = 'none';
          });
          const mobileContainer = document.querySelector('.block.md\\:hidden.space-y-4');
          if (mobileContainer) {
            mobileContainer.innerHTML = `
              <div class="bg-gray-800 rounded-lg p-6 text-center">
                <div class="flex flex-col items-center">
                  <div class="w-16 h-16 rounded-full bg-dark-700 flex items-center justify-center mb-4">
                    <i class="ti ti-broadcast text-gray-500 text-2xl"></i>
                  </div>
                  <p class="text-gray-400 font-medium mb-2">No streams found</p>
                  <p class="text-gray-500 mb-4">Create your first stream to start broadcasting</p>
                </div>
              </div>
            `;
          }
        }
        
        function displayStreams(streams) {
          if (!streams || streams.length === 0) {
            showEmptyState();
            return;
          }
          displayMobileStreams(streams);
          displayDesktopStreams(streams);
        }
        
        function displayMobileStreams(streams) {
          const mobileContainer = document.querySelector('.block.md\\:hidden.space-y-4');
          if (!mobileContainer) return;
          mobileContainer.innerHTML = '';
          streams.forEach(stream => {
            const card = createMobileStreamCard(stream);
            mobileContainer.appendChild(card);
          });
        }
        
        function displayDesktopStreams(streams) {
          const tableBody = document.querySelector('.hidden.md\\:block table tbody');
          if (!tableBody) return;
          Array.from(tableBody.querySelectorAll('tr:not(#empty-state)')).forEach(row => {
            row.remove();
          });
          const emptyState = document.getElementById('empty-state');
          if (emptyState) {
            emptyState.style.display = 'none';
          }
          streams.forEach(stream => {
            const row = createStreamTableRow(stream);
            tableBody.insertBefore(row, emptyState);
          });
        }
        
        function loadStreams(showIndicator = false) {
          // Show refresh indicator
          if (showIndicator) {
            const indicator = document.getElementById('autoRefreshIndicator');
            if (indicator) {
              indicator.classList.add('text-primary');
              const icon = indicator.querySelector('i');
              if (icon) icon.classList.add('animate-spin');
            }
          }
          
          fetch('/api/streams')
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                displayStreams(data.streams);
                updateStreamCounters(data.streams);
                setupSmartRefresh(data.streams);
                lastRefreshTime = Date.now();
              } else {
                console.error('Error fetching streams:', data.error);
                showEmptyState();
              }
            })
            .catch(error => {
              console.error('Error fetching streams:', error);
              showEmptyState();
            })
            .finally(() => {
              // Hide refresh indicator
              if (showIndicator) {
                setTimeout(() => {
                  const indicator = document.getElementById('autoRefreshIndicator');
                  if (indicator) {
                    indicator.classList.remove('text-primary');
                    const icon = indicator.querySelector('i');
                    if (icon) icon.classList.remove('animate-spin');
                  }
                }, 300);
              }
            });
        }
        
        function setupSmartRefresh(streams) {
          // Clear existing interval
          if (autoRefreshInterval) {
            clearInterval(autoRefreshInterval);
          }
          
          // Check if there are active or scheduled streams
          const hasActiveStreams = streams.some(s => s.status === 'live');
          const hasScheduledStreams = streams.some(s => s.status === 'scheduled');
          
          let refreshInterval;
          let intervalText;
          
          if (hasActiveStreams) {
            refreshInterval = 10000;
            intervalText = '10s';
            console.log('[Auto-Refresh] Active streams detected, refreshing every 10 seconds');
          } else if (hasScheduledStreams) {
            refreshInterval = 30000;
            intervalText = '30s';
            console.log('[Auto-Refresh] Scheduled streams detected, refreshing every 30 seconds');
          } else {
            refreshInterval = 120000;
            intervalText = '2m';
            console.log('[Auto-Refresh] All streams offline, refreshing every 2 minutes');
          }
          
          // Update indicator
          const indicator = document.getElementById('refreshInterval');
          if (indicator) {
            indicator.textContent = intervalText;
          }
          
          autoRefreshInterval = setInterval(() => {
            console.log('[Auto-Refresh] Refreshing stream status...');
            loadStreams(true);
          }, refreshInterval);
        }
        
        // Global references to functions defined in DOMContentLoaded
        let createMobileStreamCard = null;
        let createStreamTableRow = null;
        
        // Time format preference (stored in localStorage) - MUST BE GLOBAL
        let timeFormat24h = localStorage.getItem('timeFormat24h') !== 'false'; // default to 24h
        
        // Format time based on user preference - MUST BE GLOBAL
        function formatTimeDisplay(date) {
          if (!date) return '--:--';
          
          const hours = date.getHours();
          const minutes = date.getMinutes();
          
          if (timeFormat24h) {
            // 24-hour format: 16:30
            const h = String(hours).padStart(2, '0');
            const m = String(minutes).padStart(2, '0');
            return `${h}:${m}`;
          } else {
            // 12-hour format: 04:30 PM
            const period = hours >= 12 ? 'PM' : 'AM';
            const h12 = hours % 12 || 12; // Convert 0 to 12
            const h = String(h12).padStart(2, '0');
            const m = String(minutes).padStart(2, '0');
            return `${h}:${m} ${period}`;
          }
        }
        
        // Toggle between 12h and 24h format - MUST BE GLOBAL
        function toggleTimeFormat() {
          timeFormat24h = !timeFormat24h;
          localStorage.setItem('timeFormat24h', timeFormat24h);
          const label = document.getElementById('timeFormatLabel');
          if (label) {
            label.textContent = timeFormat24h ? '24h' : '12h';
          }
          loadStreams(); // Reload table with new format
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function () {
          // Define createMobileStreamCard in this scope
          function _createMobileStreamCard(stream) {
            const card = document.createElement('div');
            card.className = 'bg-gray-800 rounded-lg overflow-hidden shadow-md';
            card.dataset.streamId = stream.id;
            const thumbnail = stream.video_type === 'playlist' ?
              '/images/playlist-thumbnail.svg' :
              (stream.video_thumbnail || '/images/default-video-thumbnail.svg');
            // Use ACTUAL status from database (updated by streamingService)
            // Status is REAL - reflects actual FFmpeg process state
            const statusBadge = getStatusBadgeHTML(stream.status);
            const startDate = stream.start_time ? formatDate(new Date(stream.start_time)) : '';
            const scheduleDateObj = stream.schedule_time ? parseScheduleTime(stream.schedule_time) : null;
            const scheduleDate = scheduleDateObj ? formatDate(scheduleDateObj) : '';
            const scheduleTime = scheduleDateObj ? formatTime(scheduleDateObj) : '';
            let settingsDisplay = '';
            if (stream.video_type === 'playlist') {
              settingsDisplay = 'Playlist • Loading...';
              fetchPlaylistInfo(stream.video_id, stream.id);
            } else if (stream.use_advanced_settings) {
              settingsDisplay = `${stream.resolution || '1280x720'} • ${stream.bitrate || '2500'} kbps • ${stream.fps || '30'} FPS`;
            } else {
              const videoRes = stream.video_resolution || stream.resolution || '1280x720';
              const videoBitrate = stream.video_bitrate || stream.bitrate || '2500';
              const videoFps = stream.video_fps || stream.fps || '30';
              settingsDisplay = `${videoRes} • ${videoBitrate} kbps • ${videoFps} FPS`;
            }
            // Calculate start and end time from schedules
            let timeRangeDisplay = '—';
            let scheduleCountDisplay = '';
            let scheduleDetailsListHTML = '';

            if (stream.schedules && stream.schedules.length > 0) {
              const sortedSchedules = [...stream.schedules].sort((a, b) =>
                new Date(a.schedule_time) - new Date(b.schedule_time)
              );
              const firstSchedule = sortedSchedules[0];
              const lastSchedule = sortedSchedules[sortedSchedules.length - 1];

              const startTime = new Date(firstSchedule.schedule_time);
              const endTime = new Date(lastSchedule.schedule_time);
              endTime.setMinutes(endTime.getMinutes() + parseInt(lastSchedule.duration));

              timeRangeDisplay = `${formatTime(startTime)} - ${formatTime(endTime)}`;
              if (stream.schedules.length > 1) {
                const totalDuration = stream.schedules.reduce((sum, sch) => sum + parseInt(sch.duration), 0);
                scheduleCountDisplay = `${stream.schedules.length} schedules (${totalDuration} min total)`;

                // Build detailed schedule list
                scheduleDetailsListHTML = sortedSchedules.map((sch, idx) => {
                  const schStart = new Date(sch.schedule_time);
                  const schEnd = new Date(sch.schedule_time);
                  schEnd.setMinutes(schEnd.getMinutes() + parseInt(sch.duration));
                  return `<div class="text-xs text-gray-400 ml-5 mt-1">
                • ${formatTime(schStart)} - ${formatTime(schEnd)} (${sch.duration}m)
              </div>`;
                }).join('');
              }
            } else if (stream.schedule_time) {
              const startTime = new Date(stream.schedule_time);
              if (stream.duration) {
                const endTime = new Date(startTime);
                endTime.setMinutes(endTime.getMinutes() + parseInt(stream.duration));
                timeRangeDisplay = `${formatTime(startTime)} - ${formatTime(endTime)}`;
              } else {
                timeRangeDisplay = formatTime(startTime);
              }
            }
            card.innerHTML = `
        <div class="relative">
          <div class="bg-dark-700 aspect-video relative">
            <img src="${thumbnail}" class="w-full h-full object-cover" alt="${stream.title}">
            <div class="absolute top-2 right-2">
              ${statusBadge}
            </div>
          </div>
        </div>
        <div class="p-4">
          <div class="flex items-center justify-between mb-2">
            <div class="font-medium">${stream.title}</div>
            <div class="flex items-center text-sm">
              <i class="ti ti-brand-${getPlatformIcon(stream.platform)} text-${getPlatformColor(stream.platform)} mr-1"></i>
              <span>${stream.platform || 'Custom'}</span>
            </div>
          </div>
          <div class="text-xs text-gray-400 mb-2">
            ${settingsDisplay}
          </div>
          <div class="flex items-center text-sm text-gray-400 mb-2">
            <i class="ti ti-clock mr-1.5"></i>
            <span>${timeRangeDisplay}</span>
          </div>
          ${scheduleCountDisplay ? `
          <div class="mb-2">
            <div class="text-xs text-blue-400 mb-1">
              <i class="ti ti-calendar-repeat mr-1"></i>
              ${scheduleCountDisplay}
            </div>
            ${scheduleDetailsListHTML}
          </div>` : ''}
          ${stream.status === 'scheduled' ? `
          <div class="flex items-center text-sm text-yellow-500 mb-3">
            <i class="ti ti-calendar-event mr-1.5"></i>
            <span>Starts ${scheduleDate} • ${scheduleTime}</span>
          </div>` : `
          <div class="flex items-center text-sm text-gray-400 mb-3">
            <i class="ti ti-calendar mr-1.5"></i>
            <span>${startDate || 'Not started'}</span>
          </div>`}
          <div class="flex justify-between items-center">
            ${getActionButtonHTML(stream.status, stream.id, 'mobile', stream)}
            <div class="flex items-center gap-3 text-gray-400">
              <button class="hover:text-white transition-colors" onclick="editStream('${stream.id}')">
                <i class="ti ti-edit"></i>
              </button>
              <button class="hover:text-red-400 transition-colors" onclick="deleteStream('${stream.id}')">
                <i class="ti ti-trash"></i>
              </button>
            </div>
          </div>
        </div>
      `;
            return card;
          }
          
          // Assign to global scope
          createMobileStreamCard = _createMobileStreamCard;
          
          // Helper function to check if a schedule is currently active
          function isScheduleActive(stream, schedule) {
            // METHOD 1: PRECISE - Check if this schedule ID matches the active_schedule_id in stream
            if (stream.status === 'live' && stream.active_schedule_id) {
              const match = stream.active_schedule_id === schedule.id;
              console.log(`[Highlight] Method 1 - Stream ${stream.id}, Schedule ${schedule.id}, active_schedule_id: ${stream.active_schedule_id}, Match: ${match}`);
              return match;
            }
            
            // METHOD 2: FALLBACK - For streams started before this feature, use time-based detection
            if (stream.status === 'live') {
              const now = new Date();
              const schStart = parseScheduleTime(schedule.schedule_time);
              const schEnd = new Date(schStart.getTime() + (parseInt(schedule.duration) * 60 * 1000));
              
              console.log(`[Highlight] Method 2 - Stream ${stream.id}, Schedule ${schedule.id}, Now: ${now.toLocaleTimeString()}, Start: ${schStart.toLocaleTimeString()}, End: ${schEnd.toLocaleTimeString()}`);
              
              if (schedule.is_recurring && schedule.recurring_days) {
                const currentDay = now.getDay();
                const allowedDays = schedule.recurring_days.split(',').map(d => parseInt(d));
                console.log(`[Highlight] Recurring - Current day: ${currentDay}, Allowed: ${allowedDays.join(',')}, Includes: ${allowedDays.includes(currentDay)}`);
                
                if (!allowedDays.includes(currentDay)) return false;
                
                const nowTime = now.getHours() * 60 + now.getMinutes();
                const startTime = schStart.getHours() * 60 + schStart.getMinutes();
                const endTime = schEnd.getHours() * 60 + schEnd.getMinutes();
                
                // Handle schedules that cross midnight (e.g., 19:15 - 00:29)
                let inWindow;
                if (endTime < startTime) {
                  // Schedule crosses midnight
                  inWindow = nowTime >= startTime || nowTime < endTime;
                  console.log(`[Highlight] Time check (CROSS-MIDNIGHT) - Now: ${nowTime}, Start: ${startTime}, End: ${endTime}, InWindow: ${inWindow}`);
                } else {
                  // Normal schedule within same day
                  inWindow = nowTime >= startTime && nowTime < endTime;
                  console.log(`[Highlight] Time check (SAME-DAY) - Now: ${nowTime}, Start: ${startTime}, End: ${endTime}, InWindow: ${inWindow}`);
                }
                
                return inWindow;
              } else {
                // For one-time schedules
                const inWindow = now >= schStart && now < schEnd;
                console.log(`[Highlight] One-time - InWindow: ${inWindow}`);
                return inWindow;
              }
            }
            
            console.log(`[Highlight] Stream ${stream.id} not live, returning false`);
            return false;
          }
          
          function _createStreamTableRow(stream) {
            const row = document.createElement('tr');
            row.className = 'hover:bg-dark-700/50 transition-colors';
            row.dataset.streamId = stream.id;
            const thumbnail = stream.video_type === 'playlist' ?
              '/images/playlist-thumbnail.svg' :
              (stream.video_thumbnail || '/images/default-video-thumbnail.svg');
            const startDate = stream.start_time ? new Date(stream.start_time) : null;
            const scheduleDate = stream.schedule_time ? parseScheduleTime(stream.schedule_time) : null;
            let settingsDisplay = '';
            if (stream.video_type === 'playlist') {
              settingsDisplay = 'Playlist • Loading...';
              fetchPlaylistInfo(stream.video_id, stream.id);
            } else if (stream.use_advanced_settings) {
              settingsDisplay = `${stream.resolution || '1280x720'} • ${stream.bitrate || '2500'} kbps • ${stream.fps || '30'} FPS`;
            } else {
              const videoRes = stream.video_resolution || stream.resolution || '1280x720';
              const videoBitrate = stream.video_bitrate || stream.bitrate || '2500';
              const videoFps = stream.video_fps || stream.fps || '30';
              settingsDisplay = `${videoRes} • ${videoBitrate} kbps • ${videoFps} FPS`;
            }
            // Use ACTUAL status from database (updated by streamingService)
            let durationDisplay = '';
            let statusBadge = '';

            // Status is ACTUAL from backend - streamingService updates it when FFmpeg starts/stops
            // Always use badge without duration to avoid confusion
            statusBadge = getStatusBadgeHTML(stream.status);
            // Calculate start date, start time, and end time from schedules
            let startDateDisplay = '--';
            let startTimeDisplay = '—';
            let endTimeDisplay = '—';
            let scheduleDetailsHTML = '';

            if (stream.schedules && stream.schedules.length > 0) {
              const sortedSchedules = [...stream.schedules].sort((a, b) =>
                new Date(a.schedule_time) - new Date(b.schedule_time)
              );
              const firstSchedule = sortedSchedules[0];
              const lastSchedule = sortedSchedules[sortedSchedules.length - 1];

              const startTime = new Date(firstSchedule.schedule_time);
              const endTime = new Date(lastSchedule.schedule_time);
              endTime.setMinutes(endTime.getMinutes() + parseInt(lastSchedule.duration));

              startDateDisplay = formatDate(startTime);
              startTimeDisplay = formatTime(startTime);
              endTimeDisplay = formatTime(endTime);

              // Build schedule details for tooltip
              if (stream.schedules.length > 1) {
                scheduleDetailsHTML = sortedSchedules.map((sch, idx) => {
                  const schStart = new Date(sch.schedule_time);
                  const schEnd = new Date(sch.schedule_time);
                  schEnd.setMinutes(schEnd.getMinutes() + parseInt(sch.duration));
                  return `${idx + 1}. ${formatTime(schStart)} - ${formatTime(schEnd)} (${sch.duration}m)`;
                }).join('\\n');
              }
            } else if (stream.schedule_time) {
              const startTime = new Date(stream.schedule_time);
              startDateDisplay = formatDate(startTime);
              startTimeDisplay = formatTime(startTime);
              if (stream.duration) {
                const endTime = new Date(startTime);
                endTime.setMinutes(endTime.getMinutes() + parseInt(stream.duration));
                endTimeDisplay = formatTime(endTime);
              }
            }
            row.innerHTML = `
        <td class="px-4 py-4">
          <input type="checkbox" class="stream-checkbox w-4 h-4 rounded border-gray-600 text-primary focus:ring-primary focus:ring-offset-0 bg-dark-700 cursor-pointer" 
            value="${stream.id}" onchange="updateBulkActionsUI()">
        </td>
        <td class="px-6 py-4 whitespace-nowrap">
          <div class="flex items-center">
            <div class="w-20 h-12 bg-dark-700 rounded flex-shrink-0 overflow-hidden mr-3">
              <img src="${thumbnail}" class="w-full h-full object-cover" alt="${stream.title}">
            </div>
            <div>
              <div class="text-sm font-medium">${stream.title}</div>
              <div class="text-xs text-gray-400">${settingsDisplay}</div>
            </div>
          </div>
        </td>
        <td class="px-6 py-4 whitespace-nowrap">
          <div class="flex items-center">
            <i class="ti ti-brand-${getPlatformIcon(stream.platform)} text-${getPlatformColor(stream.platform)} mr-1.5"></i>
            <span class="text-sm">${stream.platform || 'Custom'}</span>
          </div>
        </td>
        <td class="px-6 py-4">
          ${stream.schedules && stream.schedules.length > 0
                ? stream.schedules.sort((a, b) => new Date(a.schedule_time) - new Date(b.schedule_time))
                  .map((sch, idx) => {
                    // Check if this schedule is currently active
                    const isActive = isScheduleActive(stream, sch);
                    const schStart = parseScheduleTime(sch.schedule_time);
                    
                    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    let recurringInfo = '';
                    if (sch.is_recurring && sch.recurring_days) {
                      const dayIndices = sch.recurring_days.split(',').map(d => parseInt(d)).sort((a, b) => a - b);
                      let dayLabel = '';
                      
                      // Check if all 7 days are selected
                      if (dayIndices.length === 7) {
                        dayLabel = 'Every Day';
                      } 
                      // Check if weekdays only (Mon-Fri = 1,2,3,4,5)
                      else if (dayIndices.length === 5 && 
                               dayIndices.every(d => [1,2,3,4,5].includes(d))) {
                        dayLabel = 'Weekdays';
                      }
                      // Check if weekend only (Sat-Sun = 6,0)
                      else if (dayIndices.length === 2 && 
                               dayIndices.every(d => [0,6].includes(d))) {
                        dayLabel = 'Weekend';
                      }
                      // Otherwise show individual days
                      else {
                        const days = dayIndices.map(d => dayNames[d]);
                        dayLabel = days.join(', ');
                      }
                      
                      recurringInfo = `<div class="flex items-center gap-1 mt-0.5">
                      ${isActive ? '<i class="ti ti-circle-check text-green-400 text-sm mr-1"></i>' : ''}
                      <i class="ti ti-repeat text-blue-400 text-xs"></i>
                      <span class="text-xs text-blue-400">${dayLabel}</span>
                    </div>`;
                    } else {
                      const schDate = new Date(sch.schedule_time);
                      recurringInfo = `<div class="flex items-center gap-1 text-xs text-gray-500">
                        ${isActive ? '<i class="ti ti-circle-check text-green-400 text-sm"></i>' : ''}
                        ${formatDate(schDate)}
                      </div>`;
                    }
                    return `<div class="${idx > 0 ? 'mt-2 pt-2 border-t border-gray-700' : ''}">
                    ${recurringInfo}
                  </div>`;
                  }).join('')
                : `<div class="text-sm text-gray-400">${startDateDisplay}</div>
               ${stream.status === 'live' && startDate ? `<div class="text-xs text-gray-500">Started: ${formatTime(startDate)}</div>` : ''}`}
        </td>
        <td class="px-6 py-4">
          ${stream.schedules && stream.schedules.length > 0
                ? stream.schedules.sort((a, b) => new Date(a.schedule_time) - new Date(b.schedule_time))
                  .map((sch, idx) => {
                    // Check if this schedule is currently active
                    const isActive = isScheduleActive(stream, sch);
                    const schStart = parseScheduleTime(sch.schedule_time);
                    
                    return `<div class="flex items-center ${idx > 0 ? 'mt-1.5' : ''}">
                    ${isActive ? '<i class="ti ti-circle-check text-green-400 text-sm mr-1"></i>' : ''}
                    <i class="ti ti-clock text-gray-400 text-xs mr-1.5"></i>
                    <span class="text-sm">${formatTime(schStart)}</span>
                  </div>`;
                  }).join('')
                : `<div class="flex items-center">
                <i class="ti ti-clock text-gray-400 mr-1.5"></i>
                <span class="text-sm">${startTimeDisplay}</span>
              </div>`}
        </td>
        <td class="px-6 py-4">
          ${stream.schedules && stream.schedules.length > 0
                ? stream.schedules.sort((a, b) => new Date(a.schedule_time) - new Date(b.schedule_time))
                  .map((sch, idx) => {
                    // Check if this schedule is currently active
                    const isActive = isScheduleActive(stream, sch);
                    const schStart = parseScheduleTime(sch.schedule_time);
                    const schEnd = new Date(schStart.getTime() + (parseInt(sch.duration) * 60 * 1000));
                    
                    return `<div class="flex items-center ${idx > 0 ? 'mt-1.5' : ''}">
                    ${isActive ? '<i class="ti ti-circle-check text-green-400 text-sm mr-1"></i>' : ''}
                    <i class="ti ti-clock-stop text-gray-400 mr-1.5 text-xs"></i>
                    <span class="text-sm">${formatTime(schEnd)}</span>
                    <span class="text-xs text-gray-500 ml-2">(${sch.duration}m)</span>
                  </div>`;
                  }).join('')
                : `<div class="flex items-center">
                <i class="ti ti-clock-stop text-gray-400 mr-1.5"></i>
                <span class="text-sm">${endTimeDisplay}</span>
              </div>`}
        </td>
        <td class="px-6 py-4 whitespace-nowrap min-w-[150px]">
          <div class="flex items-center">
            ${statusBadge}
          </div>
        </td>
        <td class="px-6 py-4 whitespace-nowrap text-right">
          <div class="flex items-center justify-end space-x-2">
            ${getActionButtonHTML(stream.status, stream.id, 'desktop', stream)}
            <div class="ml-2 flex items-center gap-1">
              <button class="p-1.5 hover:bg-dark-700 rounded transition-colors" onclick="editStream('${stream.id}')">
                <i class="ti ti-edit text-gray-400 hover:text-white"></i>
              </button>
              <button class="p-1.5 hover:bg-dark-700 rounded transition-colors" onclick="deleteStream('${stream.id}')">
                <i class="ti ti-trash text-gray-400 hover:text-red-400"></i>
              </button>
            </div>
          </div>
        </td>
      `;
            return row;
          }
          
          // Assign to global scope
          createStreamTableRow = _createStreamTableRow;
          
          // Initialize time format toggle button label
          const timeFormatLabel = document.getElementById('timeFormatLabel');
          if (timeFormatLabel) {
            timeFormatLabel.textContent = timeFormat24h ? '24h' : '12h';
          }
          
          // Now load streams after functions are assigned
          loadStreams();
          
          function formatDate(date) {
            if (!date) return '';
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
          }
          
          function formatTime(date) {
            if (!date) return '';
            return formatTimeDisplay(date);
          }
          
          // Helper function to parse schedule_time correctly
          function parseScheduleTime(scheduleTimeStr) {
            if (!scheduleTimeStr) return null;
            
            // If it has 'Z' at the end, it's UTC - JavaScript will auto-convert to local
            if (scheduleTimeStr.endsWith('Z')) {
              return new Date(scheduleTimeStr);
            }
            
            // If no 'Z', it's in local format - parse as-is
            // Format: "2025-12-16T10:42:00.000" or "2025-12-16T10:42:00"
            const timePart = scheduleTimeStr.split('T')[1].split('.')[0]; // "10:42:00"
            const datePart = scheduleTimeStr.split('T')[0]; // "2025-12-16"
            const [year, month, day] = datePart.split('-');
            const [hour, minute, second] = timePart.split(':');
            
            // Create date with local time (not UTC)
            return new Date(
              parseInt(year),
              parseInt(month) - 1, // Month is 0-indexed
              parseInt(day),
              parseInt(hour),
              parseInt(minute),
              parseInt(second) || 0
            );
          }
          
          function formatRecurringDays(recurringDaysString) {
            if (!recurringDaysString) return '';
            
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const dayIndices = recurringDaysString.split(',').map(d => parseInt(d)).sort((a, b) => a - b);
            
            // All 7 days selected
            if (dayIndices.length === 7) {
              return 'Every Day';
            }
            // Weekdays only (Mon-Fri = 1,2,3,4,5)
            else if (dayIndices.length === 5 && dayIndices.every(d => [1,2,3,4,5].includes(d))) {
              return 'Weekdays';
            }
            // Weekend only (Sat-Sun = 6,0)
            else if (dayIndices.length === 2 && dayIndices.every(d => [0,6].includes(d))) {
              return 'Weekend';
            }
            // Individual days
            else {
              return dayIndices.map(d => dayNames[d]).join(', ');
            }
          }

          function getScheduleStatus(schedule) {
            const now = new Date();
            const startTime = new Date(schedule.schedule_time);
            const endTime = new Date(startTime);
            endTime.setMinutes(endTime.getMinutes() + parseInt(schedule.duration));

            // Check database status first
            if (schedule.status === 'completed') {
              return { status: 'completed', label: 'Completed', color: 'green', icon: 'check' };
            }
            if (schedule.status === 'failed') {
              return { status: 'failed', label: 'Failed', color: 'red', icon: 'x' };
            }
            if (schedule.status === 'live' || schedule.status === 'running') {
              return { status: 'live', label: 'Live', color: 'red', icon: 'circle-dot', pulse: true };
            }

            // Calculate status based on time
            if (now < startTime) {
              return { status: 'waiting', label: 'Waiting', color: 'yellow', icon: 'clock' };
            } else if (now >= startTime && now <= endTime) {
              return { status: 'live', label: 'Live', color: 'red', icon: 'circle-dot', pulse: true };
            } else {
              return { status: 'completed', label: 'Completed', color: 'green', icon: 'check' };
            }
          }

          function getScheduleStatusBadge(schedule) {
            const statusInfo = getScheduleStatus(schedule);
            const pulseClass = statusInfo.pulse ? 'animate-pulse' : '';

            return `<span class="inline-flex items-center px-1.5 py-0.5 rounded text-xs bg-${statusInfo.color}-500/10 text-${statusInfo.color}-400 border border-${statusInfo.color}-500/30">
          <i class="ti ti-${statusInfo.icon} ${pulseClass} mr-1"></i>
          ${statusInfo.label}
        </span>`;
          }
          function getPlatformIcon(platform) {
            switch (platform) {
              case 'YouTube': return 'youtube';
              case 'Facebook': return 'facebook';
              case 'Twitch': return 'twitch';
              case 'TikTok': return 'tiktok';
              case 'Instagram': return 'instagram';
              case 'Shopee Live': return 'shopping-bag';
              case 'Restream.io': return 'live-photo';
              default: return 'broadcast';
            }
          }
          function getPlatformColor(platform) {
            switch (platform) {
              case 'YouTube': return 'red-500';
              case 'Facebook': return 'blue-500';
              case 'Twitch': return 'purple-500';
              case 'TikTok': return 'gray-100';
              case 'Instagram': return 'pink-500';
              case 'Shopee Live': return 'orange-500';
              case 'Restream.io': return 'teal-500';
              default: return 'gray-400';
            }
          }
          function getStatusBadgeHTML(status, duration = '') {
            switch (status) {
              case 'live':
                return `
            <span class="flex items-center bg-red-500/20 text-red-400 rounded-full px-3 py-1 border border-red-500/30">
              <span class="w-2 h-2 rounded-full bg-red-500 animate-pulse mr-2"></span>
              <span class="text-xs font-semibold">STREAMING</span>
            </span>
          `;
              case 'waiting':
                return `
            <span class="flex items-center bg-yellow-500/20 text-yellow-400 rounded-full px-3 py-1 border border-yellow-500/30">
              <i class="ti ti-clock text-xs mr-1.5"></i>
              <span class="text-xs font-medium">Waiting</span>
            </span>
          `;
              case 'completed':
                return `
            <span class="flex items-center bg-green-500/20 text-green-400 rounded-full px-3 py-1 border border-green-500/30">
              <i class="ti ti-check text-xs mr-1.5"></i>
              <span class="text-xs font-medium">Completed</span>
            </span>
          `;
              case 'scheduled':
                return `
            <span class="flex items-center bg-blue-500/20 text-blue-400 rounded-full px-3 py-1 border border-blue-500/30">
              <i class="ti ti-calendar-event text-xs mr-1.5"></i>
              <span class="text-xs font-medium">Scheduled</span>
            </span>
          `;
              case 'offline':
              default:
                return `
            <span class="flex items-center bg-gray-700/50 text-gray-400 rounded-full px-3 py-1 border border-gray-600/30">
              <i class="ti ti-circle text-xs mr-1.5"></i>
              <span class="text-xs font-medium">Offline</span>
            </span>
          `;
            }
          }
          function getActionButtonHTML(status, streamId, view = 'desktop', stream = null) {
            const btnClass = view === 'mobile'
              ? 'px-4 py-1.5 text-white text-xs font-medium rounded transition-colors'
              : 'inline-flex items-center px-2.5 py-1.5 text-white text-xs font-medium rounded transition-colors';
            
            // Check if stream has active schedule
            const hasSchedule = stream && stream.schedules && stream.schedules.length > 0;
            
            switch (status) {
              case 'live':
                return `
            <button 
              onclick="stopStream('${streamId}')"
              class="${btnClass} bg-red-500 hover:bg-red-600">
              Stop
            </button>
          `;
              case 'scheduled':
                return `
            <button
              onclick="cancelSchedule('${streamId}')"
              class="${btnClass} bg-yellow-500 hover:bg-yellow-600">
              Cancel
            </button>
          `;
              case 'offline':
              default:
                // If has schedule, show info instead of Start button
                if (hasSchedule) {
                  const schedule = stream.schedules[0];
                  const scheduleTime = parseScheduleTime(schedule.schedule_time);
                  const timeStr = formatTimeDisplay(scheduleTime);
                  
                  return `
            <div class="flex items-center gap-2 text-xs">
              <i class="ti ti-clock text-blue-400"></i>
              <span class="text-gray-400">Auto-start at ${timeStr}</span>
            </div>
          `;
                }
                
                // No schedule, show Start button
                return `
            <button
              onclick="startStream('${streamId}')"
              class="${btnClass} bg-primary hover:bg-blue-600">
              Start
            </button>
          `;
            }
          }
        });
        function startStream(streamId) {
          if (!streamId) return;
          const actionBtns = document.querySelectorAll(`[data-stream-id="${streamId}"] .action-btn`);
          const originalBtnStates = [];
          actionBtns.forEach(btn => {
            originalBtnStates.push({
              element: btn,
              html: btn.innerHTML,
              disabled: btn.disabled
            });
            btn.innerHTML = '<i class="ti ti-loader animate-spin"></i> Starting...';
            btn.disabled = true;
          });
          function restoreButtons() {
            originalBtnStates.forEach(state => {
              state.element.innerHTML = state.html;
              state.element.disabled = state.disabled;
            });
          }
          fetch(`/api/streams/${streamId}/status`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ status: 'live' })
          })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                if (data.scheduled) {
                  // Stream is scheduled for future
                  showNotification('Scheduled!', 'Stream scheduled successfully. It will start automatically at the scheduled time.', 'success');
                } else {
                  // Stream started immediately
                  const streamMode = data.isAdvancedMode ? "Advanced mode" : "Simple mode";
                  showNotification('Success!', `Stream started successfully! (${streamMode})`, 'success');
                }
                setTimeout(() => window.location.reload(), 1000);
              } else {
                showNotification('Error', data.error || 'Failed to start stream', 'error');
                restoreButtons();
              }
            })
            .catch(error => {
              console.error('Error starting stream:', error);
              showNotification('Error', `An error occurred while starting the stream: ${error.message}`, 'error');
              restoreButtons();
            });
        }
        function stopStream(streamId) {
          if (!streamId) return;
          const actionBtns = document.querySelectorAll(`[data-stream-id="${streamId}"] .action-btn`);
          const originalBtnStates = [];
          actionBtns.forEach(btn => {
            originalBtnStates.push({
              element: btn,
              html: btn.innerHTML,
              disabled: btn.disabled
            });
            btn.innerHTML = '<i class="ti ti-loader animate-spin"></i> Stopping...';
            btn.disabled = true;
          });
          function restoreButtons() {
            originalBtnStates.forEach(state => {
              state.element.innerHTML = state.html;
              state.element.disabled = state.disabled;
            });
          }
          fetch(`/api/streams/${streamId}/status`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ status: 'offline' })
          })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                showNotification('Success!', 'Stream stopped successfully!', 'success');
                setTimeout(() => window.location.reload(), 1000);
              } else {
                showNotification('Error', data.error || 'Failed to stop stream', 'error');
                restoreButtons();
              }
            })
            .catch(error => {
              console.error('Error stopping stream:', error);
              showNotification('Error', `An error occurred while stopping the stream: ${error.message}`, 'error');
              restoreButtons();
            });
        }
        function cancelSchedule(streamId) {
          if (!streamId) return;
          const actionBtns = document.querySelectorAll(`[data-stream-id="${streamId}"] .action-btn`);
          const originalBtnStates = [];
          actionBtns.forEach(btn => {
            originalBtnStates.push({
              element: btn,
              html: btn.innerHTML,
              disabled: btn.disabled
            });
            btn.innerHTML = '<i class="ti ti-loader animate-spin"></i> Cancelling...';
            btn.disabled = true;
          });
          function restoreButtons() {
            originalBtnStates.forEach(state => {
              state.element.innerHTML = state.html;
              state.element.disabled = state.disabled;
            });
          }
          fetch(`/api/streams/${streamId}/status`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ status: 'offline' })
          })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                showNotification('Success!', 'Schedule cancelled successfully!', 'success');
                setTimeout(() => window.location.reload(), 1000);
              } else {
                showNotification('Error', data.error || 'Failed to cancel schedule', 'error');
                restoreButtons();
              }
            })
            .catch(error => {
              console.error('Error cancelling schedule:', error);
              showNotification('Error', `An error occurred while cancelling the schedule: ${error.message}`, 'error');
              restoreButtons();
            });
        }
        // editStream function is defined below
        function deleteStream(streamId) {
          if (!streamId) return;

          showConfirmDialog(
            'Delete Stream',
            'Are you sure you want to delete this stream? This action cannot be undone.',
            'Delete',
            'Cancel',
            () => {
              fetch(`/api/streams/${streamId}`, {
                method: 'DELETE',
                headers: {
                  'Content-Type': 'application/json'
                }
              })
                .then(response => response.json())
                .then(data => {
                  if (data.success) {
                    showNotification('Success', 'Stream deleted successfully', 'success');
                    setTimeout(() => window.location.reload(), 1000);
                  } else {
                    showNotification('Error', data.error || 'Failed to delete stream', 'error');
                  }
                })
                .catch(error => {
                  console.error('Error deleting stream:', error);
                  showNotification('Error', 'An error occurred while deleting the stream', 'error');
                });
            }
          );
        }

        // Bulk Actions
        function toggleSelectAll(checkbox) {
          const checkboxes = document.querySelectorAll('.stream-checkbox');
          checkboxes.forEach(cb => cb.checked = checkbox.checked);
          updateBulkActionsUI();
        }

        function updateBulkActionsUI() {
          const checkboxes = document.querySelectorAll('.stream-checkbox:checked');
          const count = checkboxes.length;
          const bulkContainer = document.getElementById('bulkActionsContainer');
          const selectedCount = document.getElementById('selectedCount');
          const selectAllCheckbox = document.getElementById('selectAllStreams');

          if (count > 0) {
            bulkContainer.classList.remove('hidden');
            bulkContainer.classList.add('flex');
            selectedCount.textContent = `${count} selected`;
          } else {
            bulkContainer.classList.add('hidden');
            bulkContainer.classList.remove('flex');
          }

          // Update select all checkbox state
          const allCheckboxes = document.querySelectorAll('.stream-checkbox');
          const allChecked = allCheckboxes.length > 0 && Array.from(allCheckboxes).every(cb => cb.checked);
          const someChecked = Array.from(allCheckboxes).some(cb => cb.checked);

          if (selectAllCheckbox) {
            selectAllCheckbox.checked = allChecked;
            selectAllCheckbox.indeterminate = someChecked && !allChecked;
          }
        }

        function deleteSelectedStreams() {
          const checkboxes = document.querySelectorAll('.stream-checkbox:checked');
          const streamIds = Array.from(checkboxes).map(cb => cb.value);

          if (streamIds.length === 0) {
            showNotification('Warning', 'No streams selected', 'warning');
            return;
          }

          showConfirmDialog(
            'Delete Multiple Streams',
            `Are you sure you want to delete ${streamIds.length} stream(s)? This action cannot be undone.`,
            'Delete All',
            'Cancel',
            async () => {
              let successCount = 0;
              let errorCount = 0;

              showNotification('Processing', `Deleting ${streamIds.length} stream(s)...`, 'info');

              for (const streamId of streamIds) {
                try {
                  const response = await fetch(`/api/streams/${streamId}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' }
                  });
                  const data = await response.json();

                  if (data.success) {
                    successCount++;
                  } else {
                    errorCount++;
                  }
                } catch (error) {
                  console.error(`Error deleting stream ${streamId}:`, error);
                  errorCount++;
                }
              }

              if (successCount > 0) {
                showNotification('Success', `${successCount} stream(s) deleted successfully`, 'success');
              }
              if (errorCount > 0) {
                showNotification('Warning', `${errorCount} stream(s) failed to delete`, 'warning');
              }

              setTimeout(() => window.location.reload(), 1500);
            }
          );
        }
        function startCountdowns() {
          const updateTimers = () => {
            document.querySelectorAll('[data-schedule-time]').forEach(el => {
              const scheduleTime = new Date(el.dataset.scheduleTime);
              const now = new Date();
              const diff = scheduleTime - now;
              if (diff <= 0) {
                el.textContent = 'Starting soon...';
                return;
              }
              const days = Math.floor(diff / (1000 * 60 * 60 * 24));
              const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
              const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
              const seconds = Math.floor((diff % (1000 * 60)) / 1000);
              let timeText = '';
              if (days > 0) timeText = `${days}d ${hours}h ${minutes}m`;
              else if (hours > 0) timeText = `${hours}h ${minutes}m ${seconds}s`;
              else timeText = `${minutes}m ${seconds}s`;
              el.textContent = `Starts in: ${timeText}`;
            });
          };
          updateTimers();
          // Update every 5 seconds instead of 1 second (save CPU)
          setInterval(updateTimers, 5000);
        }
        document.addEventListener('DOMContentLoaded', function () {
          startCountdowns();
        });
        let editSelectedVideoData = null;
        let currentEditOrientation = 'horizontal';
        let editDesktopVideoPlayer = null;
        let editMobileVideoPlayer = null;
        let isEditStreamKeyValid = true;
        let originalStreamKey = '';
        function editStream(streamId) {
          if (!streamId) return;

          // Show loading notification
          showNotification('Loading', 'Fetching stream data...', 'info');

          fetch(`/api/streams/${streamId}`)
            .then(response => {
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              return response.json();
            })
            .then(data => {
              if (data.success) {
                openEditStreamModal(data.stream);
              } else {
                console.error('API Error:', data.error);
                showNotification('Error', data.error || 'Failed to fetch stream data', 'error');
              }
            })
            .catch(error => {
              console.error('Error fetching stream data:', error);
              showNotification('Error', `Failed to load stream: ${error.message}. Please try refreshing the page.`, 'error');
            });
        }
        function openEditStreamModal(stream) {
          try {
            // Helper function to safely set element value
            const safeSetValue = (id, value) => {
              const el = document.getElementById(id);
              if (el) el.value = value;
              else console.warn(`Element not found: ${id}`);
            };

            const safeSetText = (id, text) => {
              const el = document.getElementById(id);
              if (el) el.textContent = text;
              else console.warn(`Element not found: ${id}`);
            };

            const safeSetChecked = (id, checked) => {
              const el = document.getElementById(id);
              if (el) el.checked = checked;
              else console.warn(`Element not found: ${id}`);
            };

            originalStreamKey = stream.stream_key;
            safeSetValue('editStreamId', stream.id);
            safeSetValue('editStreamTitle', stream.title);
            safeSetValue('editRtmpUrl', stream.rtmp_url || '');
            safeSetValue('editStreamKey', stream.stream_key || '');

            if (stream.video_id) {
              safeSetValue('editSelectedVideoId', stream.video_id);
              const displayName = stream.video_type === 'playlist' ? (stream.playlist_name || stream.video_title) : stream.video_title;
              safeSetText('editSelectedVideo', displayName || 'Selected Video');

              const videoData = {
                id: stream.video_id,
                name: displayName,
                url: `/stream/${stream.video_id}`,
                thumbnail: stream.video_thumbnail,
                type: stream.video_type || 'video'
              };
              selectEditVideo(videoData);
            }

            safeSetChecked('editLoopVideo', stream.loop_video);

            const bitrateSelect = document.getElementById('editBitrate');
            if (bitrateSelect) {
              for (let i = 0; i < bitrateSelect.options.length; i++) {
                if (bitrateSelect.options[i].value == stream.bitrate) {
                  bitrateSelect.selectedIndex = i;
                  break;
                }
              }
            }
            currentEditOrientation = stream.orientation || 'horizontal';
            setEditVideoOrientation(currentEditOrientation);

            const resolutionSelect = document.getElementById('editResolutionSelect');
            if (resolutionSelect && stream.resolution) {
              let found = false;
              for (let i = 0; i < resolutionSelect.options.length; i++) {
                const option = resolutionSelect.options[i];
                const resValue = option.getAttribute(`data-${currentEditOrientation}`);
                if (resValue === stream.resolution) {
                  resolutionSelect.selectedIndex = i;
                  found = true;
                  break;
                }
              }
              if (!found) {
                resolutionSelect.value = "720";
              }
              updateEditResolutionDisplay();
            }

            const fpsSelect = document.getElementById('editFps');
            if (fpsSelect) {
              for (let i = 0; i < fpsSelect.options.length; i++) {
                if (fpsSelect.options[i].value == stream.fps) {
                  fpsSelect.selectedIndex = i;
                  break;
                }
              }
            }

            if (stream.schedule_time) {
              // Parse as local time, not UTC
              const scheduleDate = new Date(stream.schedule_time);
              const year = scheduleDate.getFullYear();
              const month = String(scheduleDate.getMonth() + 1).padStart(2, '0');
              const day = String(scheduleDate.getDate()).padStart(2, '0');
              const hours = String(scheduleDate.getHours()).padStart(2, '0');
              const minutes = String(scheduleDate.getMinutes()).padStart(2, '0');
              const formattedDate = `${year}-${month}-${day}T${hours}:${minutes}`;
              safeSetValue('editScheduleTime', formattedDate);
            } else {
              safeSetValue('editScheduleTime', '');
            }
            if (stream.duration) {
              safeSetValue('editDuration', stream.duration);
            } else {
              safeSetValue('editDuration', '');
            }
            const advancedSettingsContent = document.getElementById('editAdvancedSettingsContent');
            const advancedSettingsToggle = document.getElementById('editAdvancedSettingsToggle');
            if (advancedSettingsContent && advancedSettingsToggle) {
              if (stream.use_advanced_settings) {
                advancedSettingsToggle.checked = true;
                advancedSettingsContent.classList.remove('hidden');
              } else {
                advancedSettingsToggle.checked = false;
                advancedSettingsContent.classList.add('hidden');
              }
            }
            // Load schedules for this stream
            loadStreamSchedules(stream.id);

            const modal = document.getElementById('editStreamModal');
            if (!modal) {
              throw new Error('Edit modal not found');
            }
            document.body.style.overflow = 'hidden';
            modal.classList.remove('hidden');
            requestAnimationFrame(() => {
              modal.classList.add('active');
            });
          } catch (error) {
            console.error('Error opening edit modal:', error);
            showNotification('Error', `Failed to open edit modal: ${error.message}`, 'error');
          }
        }
        function closeEditStreamModal() {
          const modal = document.getElementById('editStreamModal');
          if (modal) {
            modal.classList.remove('active');
            modal.classList.add('hidden');
          }
          document.body.style.overflow = 'auto';

          resetEditModalForm();

          if (editDesktopVideoPlayer) {
            try {
              editDesktopVideoPlayer.pause();
              editDesktopVideoPlayer.dispose();
            } catch (e) {
              console.error('Error disposing desktop video player:', e);
            }
            editDesktopVideoPlayer = null;
          }
          if (editMobileVideoPlayer) {
            try {
              editMobileVideoPlayer.pause();
              editMobileVideoPlayer.dispose();
            } catch (e) {
              console.error('Error disposing mobile video player:', e);
            }
            editMobileVideoPlayer = null;
          }
        }
        function resetEditModalForm() {
          const form = document.getElementById('editStreamForm');
          if (form) form.reset();
          
          const streamId = document.getElementById('editStreamId');
          if (streamId) streamId.value = '';
          
          const selectedVideoId = document.getElementById('editSelectedVideoId');
          if (selectedVideoId) selectedVideoId.value = '';
          
          const selectedVideo = document.getElementById('editSelectedVideo');
          if (selectedVideo) selectedVideo.textContent = 'Choose a video...';
          
          const desktopPreview = document.getElementById('editVideoPreview');
          const desktopEmptyPreview = document.getElementById('editEmptyPreview');
          const mobilePreview = document.getElementById('editVideoPreviewMobile');
          const mobileEmptyPreview = document.getElementById('editEmptyPreviewMobile');
          
          if (desktopPreview) desktopPreview.classList.add('hidden');
          if (mobilePreview) mobilePreview.classList.add('hidden');
          if (desktopEmptyPreview) desktopEmptyPreview.classList.remove('hidden');
          if (mobileEmptyPreview) mobileEmptyPreview.classList.remove('hidden');

          if (desktopEmptyPreview) {
            const desktopEmptyContent = desktopEmptyPreview.querySelector('div');
            if (desktopEmptyContent) {
              desktopEmptyContent.innerHTML = `
                <i class="ti ti-video text-4xl text-gray-600 mb-2"></i>
                <p class="text-sm text-gray-500">Select a video to preview</p>
              `;
            }
          }

          if (mobileEmptyPreview) {
            const mobileEmptyContent = mobileEmptyPreview.querySelector('div');
            if (mobileEmptyContent) {
              mobileEmptyContent.innerHTML = `
                <i class="ti ti-video text-4xl text-gray-600 mb-2"></i>
                <p class="text-sm text-gray-500">Select a video to preview</p>
              `;
            }
          }

          const advancedSettingsContent = document.getElementById('editAdvancedSettingsContent');
          const advancedSettingsToggle = document.getElementById('editAdvancedSettingsToggle');
          if (advancedSettingsContent && advancedSettingsToggle) {
            advancedSettingsToggle.checked = false;
            advancedSettingsContent.classList.add('hidden');
          }
        }
        function toggleEditVideoSelector() {
          const dropdown = document.getElementById('editVideoSelectorDropdown');
          if (dropdown.classList.contains('hidden')) {
            dropdown.classList.remove('hidden');
            if (!dropdown.dataset.loaded) {
              loadEditGalleryVideos();
              dropdown.dataset.loaded = 'true';
            }
          } else {
            dropdown.classList.add('hidden');
          }
        }
        async function loadEditGalleryVideos() {
          const container = document.getElementById('editVideoListContainer');
          if (!container) {
            console.error("Edit video list container not found");
            return;
          }
          container.innerHTML = '<div class="text-center py-3"><i class="ti ti-loader animate-spin mr-2"></i>Loading content...</div>';
          try {
            const response = await fetch('/api/stream/content');
            const content = await response.json();
            window.allEditStreamContent = content;
            displayEditFilteredVideos(content);
            const searchInput = document.getElementById('editVideoSearchInput');
            if (searchInput) {
              searchInput.removeEventListener('input', handleEditVideoSearch);
              searchInput.addEventListener('input', handleEditVideoSearch);
              setTimeout(() => searchInput.focus(), 10);
            }
          } catch (error) {
            console.error('Error loading content:', error);
            container.innerHTML = '<div class="text-center py-5 text-red-400"><i class="ti ti-alert-circle text-2xl mb-2"></i><p>Failed to load content</p></div>';
          }
        }
        function handleEditVideoSearch(e) {
          const searchTerm = e.target.value.toLowerCase();
          const filteredContent = window.allEditStreamContent.filter(item =>
            item.name.toLowerCase().includes(searchTerm) ||
            (item.type === 'playlist' && item.description && item.description.toLowerCase().includes(searchTerm))
          );
          displayEditFilteredVideos(filteredContent);
        }
        function displayEditFilteredVideos(videos) {
          const container = document.getElementById('editVideoListContainer');
          if (!videos || !videos.length) {
            container.innerHTML = '<div class="text-center py-5 text-gray-400"><p>No content found</p></div>';
            return;
          }
          container.innerHTML = '';
          videos.forEach(item => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'w-full flex items-start space-x-3 p-2 rounded hover:bg-dark-600 transition-colors text-left';
            button.onclick = () => selectEditVideo(item);

            if (item.type === 'playlist') {
              button.innerHTML = `
            <div class="w-16 h-12 bg-gradient-to-br from-blue-600 to-purple-600 rounded flex-shrink-0 overflow-hidden relative">
              <img src="${item.thumbnail}" alt="" 
                class="w-full h-full object-cover rounded" 
                onerror="this.src='/images/playlist-thumbnail.svg'">
              <div class="absolute top-0 right-0 bg-green-500 text-white text-xs px-1 rounded-bl text-[8px] font-bold">PL</div>
            </div>
            <div class="flex-1 min-w-0 ml-3 text-left">
              <p class="text-sm font-medium text-white truncate flex items-center">
                <i class="ti ti-playlist text-blue-400 mr-1 text-xs"></i>
                ${item.name}
              </p>
              <p class="text-xs text-blue-300">${item.resolution || 'Unknown'} • ${item.duration || '00:00'}</p>
            </div>
          `;
            } else {
              button.innerHTML = `
            <div class="w-16 h-12 bg-dark-800 rounded flex-shrink-0 overflow-hidden">
              <img src="${item.thumbnail || '/images/default-thumbnail.jpg'}" alt="" 
                class="w-full h-full object-cover rounded" 
                onerror="this.src='/images/default-thumbnail.jpg'">
            </div>
            <div class="flex-1 min-w-0 ml-3 text-left">
              <p class="text-sm font-medium text-white truncate">${item.name}</p>
              <p class="text-xs text-gray-400">${item.resolution || 'Unknown'} • ${item.duration || '00:00'}</p>
            </div>
          `;
            }
            container.appendChild(button);
          });
        }
        function selectEditVideo(video) {
          editSelectedVideoData = video;
          const displayText = video.type === 'playlist' ? `[Playlist] ${video.name}` : video.name;
          const selectedVideoEl = document.getElementById('editSelectedVideo');
          const selectedVideoIdEl = document.getElementById('editSelectedVideoId');

          if (selectedVideoEl) selectedVideoEl.textContent = displayText;
          if (selectedVideoIdEl) selectedVideoIdEl.value = video.id;

          const desktopPreview = document.getElementById('editVideoPreview');
          const desktopEmptyPreview = document.getElementById('editEmptyPreview');
          const mobilePreview = document.getElementById('editVideoPreviewMobile');
          const mobileEmptyPreview = document.getElementById('editEmptyPreviewMobile');

          if (!desktopPreview || !desktopEmptyPreview) {
            console.warn('Edit video preview elements not found');
            return;
          }

          if (video.type === 'playlist') {
            if (desktopPreview) desktopPreview.classList.add('hidden');
            if (mobilePreview) mobilePreview.classList.add('hidden');
            if (desktopEmptyPreview) desktopEmptyPreview.classList.remove('hidden');
            if (mobileEmptyPreview) mobileEmptyPreview.classList.remove('hidden');

            const desktopEmptyContent = desktopEmptyPreview.querySelector('div');
            const mobileEmptyContent = mobileEmptyPreview.querySelector('div');

            if (desktopEmptyContent) {
              desktopEmptyContent.innerHTML = `
            <i class="ti ti-playlist text-4xl text-blue-400 mb-2"></i>
            <p class="text-sm text-gray-300 font-medium">${video.name}</p>
            <p class="text-xs text-blue-300 mt-1">Playlist selected • ${video.duration || 'Unknown duration'}</p>
          `;
            }

            if (mobileEmptyContent) {
              mobileEmptyContent.innerHTML = `
            <i class="ti ti-playlist text-4xl text-blue-400 mb-2"></i>
            <p class="text-sm text-gray-300 font-medium">${video.name}</p>
            <p class="text-xs text-blue-300 mt-1">Playlist selected • ${video.duration || 'Unknown duration'}</p>
          `;
            }
          }

          const dropdown = document.getElementById('editVideoSelectorDropdown');
          if (dropdown) dropdown.classList.add('hidden');
        }
        // Video preview removed to save RAM (~45 MB)
        // Users can see video title and thumbnail instead
        function setEditVideoOrientation(orientation) {
          currentEditOrientation = orientation;
          const horizontalBtn = document.querySelector('[onclick="setEditVideoOrientation(\'horizontal\')"]');
          const verticalBtn = document.querySelector('[onclick="setEditVideoOrientation(\'vertical\')"]');
          horizontalBtn.classList.remove('edit-active-orientation', 'bg-primary');
          horizontalBtn.classList.add('bg-dark-700');
          verticalBtn.classList.remove('edit-active-orientation', 'bg-primary');
          verticalBtn.classList.add('bg-dark-700');
          if (orientation === 'horizontal') {
            horizontalBtn.classList.add('edit-active-orientation', 'bg-primary');
            horizontalBtn.classList.remove('bg-dark-700');
          } else {
            verticalBtn.classList.add('edit-active-orientation', 'bg-primary');
            verticalBtn.classList.remove('bg-dark-700');
          }
          updateEditResolutionDisplay();
        }
        function updateEditResolutionDisplay() {
          const select = document.getElementById('editResolutionSelect');
          const selected = select.options[select.selectedIndex];
          const resValue = selected.getAttribute(`data-${currentEditOrientation}`);
          if (resValue) {
            document.getElementById('editCurrentResolution').textContent = resValue;
          }
        }
        function toggleEditStreamKeyVisibility() {
          const keyInput = document.getElementById('editStreamKey');
          const eyeIcon = document.getElementById('editStreamKeyToggle');
          if (keyInput.type === 'password') {
            keyInput.type = 'text';
            eyeIcon.classList.remove('ti-eye');
            eyeIcon.classList.add('ti-eye-off');
          } else {
            keyInput.type = 'password';
            eyeIcon.classList.remove('ti-eye-off');
            eyeIcon.classList.add('ti-eye');
          }
        }
        document.addEventListener('DOMContentLoaded', function () {
          const editResolutionSelect = document.getElementById('editResolutionSelect');
          if (editResolutionSelect) {
            editResolutionSelect.addEventListener('change', updateEditResolutionDisplay);
          }
          const editForm = document.getElementById('editStreamForm');
          if (editForm) {
            editForm.addEventListener('submit', function (e) {
              e.preventDefault();
              const streamId = document.getElementById('editStreamId').value;
              if (!streamId) {
                showNotification('Warning', 'Stream ID is missing.', 'warning');
                return;
              }
              const videoId = document.getElementById('editSelectedVideoId').value;
              if (!videoId) {
                showNotification('Warning', 'Please select a video before updating the stream.', 'warning');
                return;
              }
              const formData = {
                streamTitle: document.getElementById('editStreamTitle').value,
                videoId: videoId,
                rtmpUrl: document.getElementById('editRtmpUrl').value,
                streamKey: document.getElementById('editStreamKey').value,
                bitrate: document.getElementById('editBitrate').value,
                fps: document.getElementById('editFps').value,
                loopVideo: document.getElementById('editLoopVideo').checked,
                orientation: currentEditOrientation,
                resolution: document.getElementById('editCurrentResolution').textContent,
                useAdvancedSettings: document.getElementById('editAdvancedSettingsToggle').checked
              };
              // Collect multiple schedules
              const schedules = collectEditSchedules();
              if (schedules.length > 0) {
                formData.schedules = schedules;
              }
              const csrfToken = document.querySelector('input[name="_csrf"]')?.value;
              fetch(`/api/streams/${streamId}`, {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  ...(csrfToken ? { 'X-CSRF-Token': csrfToken } : {})
                },
                body: JSON.stringify(formData)
              })
                .then(response => response.json())
                .then(data => {
                  if (data.success) {
                    showNotification('Success!', 'Stream updated successfully!', 'success');
                    closeEditStreamModal();
                    setTimeout(() => {
                      window.location.reload();
                    }, 500);
                  } else {
                    showNotification('Error', data.error || 'Failed to update stream', 'error');
                  }
                })
                .catch(error => {
                  console.error('Error:', error);
                  showNotification('Error', 'An error occurred while updating the stream', 'error');
                });
            });
          }
          startCountdowns();
        });
        const editPlatformSelector = document.getElementById('editPlatformSelector');
        const editPlatformDropdown = document.getElementById('editPlatformDropdown');
        if (editPlatformSelector && editPlatformDropdown) {
          editPlatformSelector.addEventListener('click', function () {
            editPlatformDropdown.classList.toggle('hidden');
          });
          document.addEventListener('click', function (e) {
            if (!editPlatformSelector.contains(e.target) && !editPlatformDropdown.contains(e.target)) {
              editPlatformDropdown.classList.add('hidden');
            }
          });
          const editPlatformOptions = editPlatformDropdown.querySelectorAll('.platform-option');
          editPlatformOptions.forEach(option => {
            option.addEventListener('click', function () {
              document.getElementById('editRtmpUrl').value = this.getAttribute('data-url');
              editPlatformDropdown.classList.add('hidden');
            });
          });
        }
        document.addEventListener('DOMContentLoaded', function () {
          setupAdvancedSettings('advancedSettingsToggle', 'advancedSettingsContent');
          setupAdvancedSettings('editAdvancedSettingsToggle', 'editAdvancedSettingsContent');
        });
        function setupAdvancedSettings(toggleId, contentId) {
          const toggle = document.getElementById(toggleId);
          const content = document.getElementById(contentId);
          if (toggle && content) {
            toggle.addEventListener('change', function () {
              if (this.checked) {
                content.classList.remove('hidden');
              } else {
                content.classList.add('hidden');
              }
            });
          }
        }

        // Stream Mode Toggle
        let currentStreamMode = 'schedule'; // 'now' or 'schedule'

        function toggleStreamMode(mode) {
          currentStreamMode = mode;
          const nowBtn = document.getElementById('streamNowBtn');
          const scheduleBtn = document.getElementById('streamScheduleBtn');
          const scheduleSection = document.getElementById('scheduleSettingsSection');
          const scheduleSlotsContainer = document.getElementById('scheduleSlotsContainer');
          const modeDescription = document.getElementById('streamModeDescription');

          if (mode === 'now') {
            // Stream Now mode
            nowBtn.classList.add('bg-primary', 'text-white');
            nowBtn.classList.remove('text-gray-400', 'hover:bg-dark-600');
            scheduleBtn.classList.remove('bg-primary', 'text-white');
            scheduleBtn.classList.add('text-gray-400', 'hover:bg-dark-600');
            scheduleSection.classList.add('hidden');
            scheduleSlotsContainer.classList.add('hidden');
            modeDescription.textContent = 'Stream will start immediately after creation. You can stop it manually anytime.';
          } else {
            // Schedule mode
            scheduleBtn.classList.add('bg-primary', 'text-white');
            scheduleBtn.classList.remove('text-gray-400', 'hover:bg-dark-600');
            nowBtn.classList.remove('bg-primary', 'text-white');
            nowBtn.classList.add('text-gray-400', 'hover:bg-dark-600');
            scheduleSection.classList.remove('hidden');
            scheduleSlotsContainer.classList.remove('hidden');
            modeDescription.textContent = 'Schedule your stream to start automatically at specific times';
          }
        }

        // Calculate duration from start and end time
        function calculateDurationFromEndTime(input) {
          const slot = input.closest('.schedule-slot');
          const startTimeInput = slot.querySelector('.schedule-time');
          const endTimeInput = slot.querySelector('.schedule-endtime');
          const durationInput = slot.querySelector('.schedule-duration');
          const hoursInput = slot.querySelector('.duration-hours');
          const minutesInput = slot.querySelector('.duration-minutes');

          if (!startTimeInput.value || !endTimeInput.value) {
            return;
          }

          const [startHour, startMin] = startTimeInput.value.split(':').map(Number);
          const [endHour, endMin] = endTimeInput.value.split(':').map(Number);

          let durationMinutes = (endHour * 60 + endMin) - (startHour * 60 + startMin);

          if (durationMinutes <= 0) {
            durationMinutes += 24 * 60;
          }

          durationInput.value = durationMinutes;
          hoursInput.value = Math.floor(durationMinutes / 60);
          minutesInput.value = durationMinutes % 60;
        }

        // Calculate end time from start and duration
        function calculateFromDuration(input) {
          const slot = input.closest('.schedule-slot');
          const startTimeInput = slot.querySelector('.schedule-time');
          const endTimeInput = slot.querySelector('.schedule-endtime');
          const durationInput = slot.querySelector('.schedule-duration');
          const hoursInput = slot.querySelector('.duration-hours');
          const minutesInput = slot.querySelector('.duration-minutes');

          const hours = parseInt(hoursInput.value) || 0;
          const minutes = parseInt(minutesInput.value) || 0;
          const totalMinutes = (hours * 60) + minutes;

          durationInput.value = totalMinutes;

          if (!startTimeInput.value) {
            return;
          }

          const [startHour, startMin] = startTimeInput.value.split(':').map(Number);
          let endTotalMinutes = startHour * 60 + startMin + totalMinutes;

          if (endTotalMinutes >= 24 * 60) {
            endTotalMinutes = endTotalMinutes % (24 * 60);
          }

          const endHour = Math.floor(endTotalMinutes / 60);
          const endMin = endTotalMinutes % 60;

          endTimeInput.value = `${endHour.toString().padStart(2, '0')}:${endMin.toString().padStart(2, '0')}`;
        }

        // Multiple Schedule Functions
        function addScheduleSlot() {
          console.log('[addScheduleSlot] Adding new schedule slot...');
          const container = document.getElementById('scheduleSlotsContainer');
          const slotCount = container.querySelectorAll('.schedule-slot').length;
          const uniqueId = Date.now(); // Unique ID for radio button names

          const slotHTML = `
        <div class="schedule-slot p-3 bg-dark-700/50 rounded-lg border border-gray-600">
          <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 mb-3">
            <div>
              <label class="text-xs text-gray-400 mb-1 block">Start</label>
              <input type="time" class="schedule-time w-full h-[36px] px-2 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary text-xs [color-scheme:dark]" onchange="calculateDurationFromEndTime(this)">
            </div>
            <div>
              <label class="text-xs text-gray-400 mb-1 block">End</label>
              <input type="time" class="schedule-endtime w-full h-[36px] px-2 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary text-xs [color-scheme:dark]" onchange="calculateDurationFromEndTime(this)">
            </div>
            <div>
              <label class="text-xs text-gray-400 mb-1 block">Duration</label>
              <div class="flex gap-1">
                <input type="number" min="0" max="23" value="1" class="duration-hours w-full h-[36px] px-1 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary text-xs text-center" placeholder="H" onchange="calculateFromDuration(this)">
                <span class="text-xs text-gray-400 flex items-center">:</span>
                <input type="number" min="0" max="59" value="0" class="duration-minutes w-full h-[36px] px-1 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary text-xs text-center" placeholder="M" onchange="calculateFromDuration(this)">
              </div>
              <input type="hidden" class="schedule-duration" value="60">
            </div>
            <div>
              <label class="text-xs text-gray-400 mb-1 block opacity-0">Del</label>
              <button type="button" onclick="removeScheduleSlot(this)" class="w-full h-[36px] flex items-center justify-center bg-red-500/20 hover:bg-red-500/30 text-red-500 border border-red-500/50 rounded-lg transition-colors">
                <i class="ti ti-trash text-sm"></i>
              </button>
            </div>
          </div>
          
          <div class="space-y-2">
            <div class="flex items-center justify-between">
              <label class="text-xs text-gray-400">Recurring Days:</label>
              <button type="button" onclick="selectAllDaysInSlot(this)" class="px-2 py-1 text-xs bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors">
                All Days
              </button>
            </div>
            <div class="flex gap-1 flex-wrap">
              <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="0">Sun</button>
              <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="1">Mon</button>
              <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="2">Tue</button>
              <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="3">Wed</button>
              <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="4">Thu</button>
              <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="5">Fri</button>
              <button type="button" class="recurring-day px-2 py-1 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="6">Sat</button>
            </div>
          </div>
        </div>
      `;
          console.log('[addScheduleSlot] Inserting HTML:', slotHTML.substring(0, 200) + '...');
          container.insertAdjacentHTML('beforeend', slotHTML);
          console.log('[addScheduleSlot] Attaching recurring day listeners...');
          attachRecurringDayListeners();
          updateRemoveButtons();
          console.log('[addScheduleSlot] Schedule slot added successfully');
        }

        function removeScheduleSlot(button) {
          const slot = button.closest('.schedule-slot');
          const container = document.getElementById('scheduleSlotsContainer');

          // Don't allow removing if only one slot left
          if (container.querySelectorAll('.schedule-slot').length > 1) {
            slot.remove();
            updateRemoveButtons();
          }
        }

        // Attach recurring day listeners for new stream modal
        function attachRecurringDayListeners() {
          const container = document.getElementById('scheduleSlotsContainer');
          if (!container) return;

          container.querySelectorAll('.recurring-day').forEach(button => {
            button.removeEventListener('click', handleRecurringDayClick);
            button.addEventListener('click', handleRecurringDayClick);
          });
        }

        function handleRecurringDayClick(e) {
          e.preventDefault();
          const button = e.currentTarget;
          button.classList.toggle('bg-primary');
          button.classList.toggle('border-primary');
          button.classList.toggle('text-white');
        }

        // Select all days in first schedule slot (for initial modal)
        function selectAllDays(button) {
          const slot = button.closest('.schedule-slot') || document.querySelector('#scheduleSlotsContainer .schedule-slot');
          if (!slot) return;
          
          const dayButtons = slot.querySelectorAll('.recurring-day');
          const allSelected = Array.from(dayButtons).every(btn => btn.classList.contains('bg-primary'));
          
          dayButtons.forEach(btn => {
            if (allSelected) {
              // Deselect all
              btn.classList.remove('bg-primary', 'border-primary', 'text-white');
            } else {
              // Select all
              btn.classList.add('bg-primary', 'border-primary', 'text-white');
            }
          });
        }

        // Select all days in specific slot (for added slots)
        function selectAllDaysInSlot(button) {
          const slot = button.closest('.schedule-slot');
          if (!slot) return;
          
          const dayButtons = slot.querySelectorAll('.recurring-day');
          const allSelected = Array.from(dayButtons).every(btn => btn.classList.contains('bg-primary'));
          
          dayButtons.forEach(btn => {
            if (allSelected) {
              // Deselect all
              btn.classList.remove('bg-primary', 'border-primary', 'text-white');
            } else {
              // Select all
              btn.classList.add('bg-primary', 'border-primary', 'text-white');
            }
          });
        }

        function updateRemoveButtons() {
          const container = document.getElementById('scheduleSlotsContainer');
          const slots = container.querySelectorAll('.schedule-slot');
          const buttons = container.querySelectorAll('.schedule-slot button');

          // Disable remove button if only one slot
          buttons.forEach(btn => {
            btn.disabled = slots.length === 1;
          });
        }

        function collectSchedules() {
          const slots = document.querySelectorAll('#scheduleSlotsContainer .schedule-slot');
          const schedules = [];

          slots.forEach(slot => {
            const time = slot.querySelector('.schedule-time').value;
            const duration = slot.querySelector('.schedule-duration').value;

            if (time && duration) {
              // Check if any recurring days are selected
              const selectedDays = [];
              slot.querySelectorAll('.recurring-day').forEach(btn => {
                if (btn.classList.contains('bg-primary')) {
                  selectedDays.push(btn.dataset.day);
                }
              });
              const isRecurring = selectedDays.length > 0;
              
              // Create datetime in user's local timezone
              const now = new Date();
              const [hours, minutes] = time.split(':').map(Number);
              
              // Create schedule date starting from today
              let scheduleDate = new Date();
              scheduleDate.setHours(hours, minutes, 0, 0);
              
              // If time has already passed today, use tomorrow (for both recurring and one-time)
              if (scheduleDate <= now) {
                scheduleDate.setDate(scheduleDate.getDate() + 1);
                console.log(`[Schedule] Time ${time} has passed today, scheduling for tomorrow`);
              }
              
              const year = scheduleDate.getFullYear();
              const month = String(scheduleDate.getMonth() + 1).padStart(2, '0');
              const day = String(scheduleDate.getDate()).padStart(2, '0');
              
              // Format as local time WITHOUT timezone (no 'Z' at end)
              // This tells the system it's already in local time
              const localTimeString = `${year}-${month}-${day}T${time}:00.000`;
              
              // Get user's timezone for reference
              const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
              
              console.log(`[Schedule] Created schedule: ${localTimeString} (${userTimezone})`);
              
              const scheduleData = {
                schedule_time: localTimeString, // Local time format (no Z)
                user_timezone: userTimezone, // Store user's timezone for reference
                duration: parseInt(duration)
              };

              // Add recurring info if days are selected
              if (isRecurring) {
                scheduleData.is_recurring = true;
                scheduleData.recurring_days = selectedDays.join(',');
              }

              schedules.push(scheduleData);
            }
          });

          return schedules;
        }

        // Edit Modal Schedule Functions
        function addEditScheduleSlot() {
          const container = document.getElementById('editScheduleSlotsContainer');
          const slotHTML = `
        <div class="schedule-slot p-3 bg-dark-700/50 rounded-lg border border-gray-600">
          <div class="flex gap-3 items-start mb-3">
            <div class="flex-1">
              <label class="text-xs text-gray-400 mb-1.5 block">Start</label>
              <input type="time" class="schedule-time w-full h-[36px] px-3 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary text-sm [color-scheme:dark]" onchange="calculateEditDurationFromEndTime(this)">
            </div>
            <div class="flex-1">
              <label class="text-xs text-gray-400 mb-1.5 block">End</label>
              <input type="time" class="schedule-endtime w-full h-[36px] px-3 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary text-sm [color-scheme:dark]" onchange="calculateEditDurationFromEndTime(this)">
            </div>
            <div class="flex-1">
              <label class="text-xs text-gray-400 mb-1.5 block">Duration</label>
              <div class="flex gap-1.5">
                <input type="number" min="0" max="23" value="1" class="duration-hours w-full h-[36px] px-2 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary text-sm text-center" placeholder="H" onchange="calculateEditFromDuration(this)">
                <span class="text-sm text-gray-400 flex items-center">:</span>
                <input type="number" min="0" max="59" value="0" class="duration-minutes w-full h-[36px] px-2 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary text-sm text-center" placeholder="M" onchange="calculateEditFromDuration(this)">
              </div>
              <input type="hidden" class="schedule-duration" value="60">
            </div>
            <div class="pt-6">
              <button type="button" onclick="removeEditScheduleSlot(this)" class="h-[36px] w-[36px] flex items-center justify-center bg-red-500/20 hover:bg-red-500/30 text-red-500 border border-red-500/50 rounded-lg transition-colors">
                <i class="ti ti-trash text-base"></i>
              </button>
            </div>
          </div>
          <div class="flex gap-3 items-center flex-wrap">
            <label class="text-xs text-gray-400 flex-shrink-0">Recurring:</label>
            <div class="flex gap-1.5 flex-wrap flex-1">
              <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="0">Sun</button>
              <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="1">Mon</button>
              <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="2">Tue</button>
              <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="3">Wed</button>
              <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="4">Thu</button>
              <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="5">Fri</button>
              <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors" data-day="6">Sat</button>
            </div>
            <button type="button" onclick="selectAllDaysInEditSlot(this)" class="px-3 py-1.5 text-xs bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors flex-shrink-0">
              All Days
            </button>
          </div>
        </div>
      `;
          container.insertAdjacentHTML('beforeend', slotHTML);
          attachEditRecurringDayListeners();
          updateEditRemoveButtons();
        }

        function removeEditScheduleSlot(button) {
          const slot = button.closest('.schedule-slot');
          const container = document.getElementById('editScheduleSlotsContainer');

          if (container.querySelectorAll('.schedule-slot').length > 1) {
            slot.remove();
            updateEditRemoveButtons();
          }
        }

        function updateEditRemoveButtons() {
          const container = document.getElementById('editScheduleSlotsContainer');
          const slots = container.querySelectorAll('.schedule-slot');
          const buttons = container.querySelectorAll('.schedule-slot button');

          buttons.forEach(btn => {
            btn.disabled = slots.length === 1;
          });
        }

        // Select all days in edit slot
        function selectAllDaysInEditSlot(button) {
          const slot = button.closest('.schedule-slot');
          if (!slot) return;
          
          const dayButtons = slot.querySelectorAll('.recurring-day');
          const allSelected = Array.from(dayButtons).every(btn => btn.classList.contains('bg-primary'));
          
          dayButtons.forEach(btn => {
            if (allSelected) {
              // Deselect all
              btn.classList.remove('bg-primary', 'border-primary', 'text-white');
            } else {
              // Select all
              btn.classList.add('bg-primary', 'border-primary', 'text-white');
            }
          });
        }

        // Calculate duration from start and end time for edit modal
        function calculateEditDurationFromEndTime(input) {
          const slot = input.closest('.schedule-slot');
          const startTimeInput = slot.querySelector('.schedule-time');
          const endTimeInput = slot.querySelector('.schedule-endtime');
          const durationInput = slot.querySelector('.schedule-duration');
          const hoursInput = slot.querySelector('.duration-hours');
          const minutesInput = slot.querySelector('.duration-minutes');

          if (!startTimeInput.value || !endTimeInput.value) {
            return;
          }

          const [startHour, startMin] = startTimeInput.value.split(':').map(Number);
          const [endHour, endMin] = endTimeInput.value.split(':').map(Number);

          let durationMinutes = (endHour * 60 + endMin) - (startHour * 60 + startMin);

          if (durationMinutes <= 0) {
            durationMinutes += 24 * 60;
          }

          durationInput.value = durationMinutes;
          hoursInput.value = Math.floor(durationMinutes / 60);
          minutesInput.value = durationMinutes % 60;
        }

        // Calculate end time from start and duration for edit modal
        function calculateEditFromDuration(input) {
          const slot = input.closest('.schedule-slot');
          const startTimeInput = slot.querySelector('.schedule-time');
          const endTimeInput = slot.querySelector('.schedule-endtime');
          const durationInput = slot.querySelector('.schedule-duration');
          const hoursInput = slot.querySelector('.duration-hours');
          const minutesInput = slot.querySelector('.duration-minutes');

          const hours = parseInt(hoursInput.value) || 0;
          const minutes = parseInt(minutesInput.value) || 0;
          const totalMinutes = (hours * 60) + minutes;

          durationInput.value = totalMinutes;

          if (!startTimeInput.value) {
            return;
          }

          const [startHour, startMin] = startTimeInput.value.split(':').map(Number);
          let endTotalMinutes = startHour * 60 + startMin + totalMinutes;

          if (endTotalMinutes >= 24 * 60) {
            endTotalMinutes = endTotalMinutes % (24 * 60);
          }

          const endHour = Math.floor(endTotalMinutes / 60);
          const endMin = endTotalMinutes % 60;

          endTimeInput.value = `${endHour.toString().padStart(2, '0')}:${endMin.toString().padStart(2, '0')}`;
        }

        // Attach recurring day listeners for edit modal
        function attachEditRecurringDayListeners() {
          const container = document.getElementById('editScheduleSlotsContainer');
          if (!container) return;

          container.querySelectorAll('.recurring-day').forEach(button => {
            button.removeEventListener('click', handleEditRecurringDayClick);
            button.addEventListener('click', handleEditRecurringDayClick);
          });
        }

        function handleEditRecurringDayClick(e) {
          e.preventDefault();
          const button = e.currentTarget;
          button.classList.toggle('bg-primary');
          button.classList.toggle('border-primary');
          button.classList.toggle('text-white');
        }

        function collectEditSchedules() {
          const slots = document.querySelectorAll('#editScheduleSlotsContainer .schedule-slot');
          const schedules = [];

          slots.forEach(slot => {
            const time = slot.querySelector('.schedule-time').value;
            const duration = slot.querySelector('.schedule-duration').value;
            
            // Get selected recurring days
            const selectedDays = [];
            slot.querySelectorAll('.recurring-day').forEach(btn => {
              if (btn.classList.contains('bg-primary')) {
                selectedDays.push(btn.dataset.day);
              }
            });

            if (time && duration) {
              // Create datetime in user's local timezone
              const now = new Date();
              const [hours, minutes] = time.split(':').map(Number);
              
              // Check if it's recurring
              const isRecurring = selectedDays.length > 0;
              
              // Create schedule date starting from today
              let scheduleDate = new Date();
              scheduleDate.setHours(hours, minutes, 0, 0);
              
              // If time has already passed today AND it's not recurring, use tomorrow
              if (!isRecurring && scheduleDate <= now) {
                scheduleDate.setDate(scheduleDate.getDate() + 1);
                console.log(`[Edit Schedule] Time ${time} has passed today, scheduling for tomorrow`);
              }
              
              const year = scheduleDate.getFullYear();
              const month = String(scheduleDate.getMonth() + 1).padStart(2, '0');
              const day = String(scheduleDate.getDate()).padStart(2, '0');
              
              // Format as local time WITHOUT timezone (no 'Z' at end)
              const localTimeString = `${year}-${month}-${day}T${time}:00.000`;
              
              // Get user's timezone
              const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
              
              console.log(`[Edit Schedule] Created schedule: ${localTimeString} (${userTimezone})`);
              
              const schedule = {
                schedule_time: localTimeString, // Local time format (no Z)
                user_timezone: userTimezone, // User's timezone
                duration: parseInt(duration)
              };
              
              // Add recurring info if days are selected
              if (isRecurring) {
                schedule.is_recurring = true;
                schedule.recurring_days = selectedDays.join(',');
              }
              
              schedules.push(schedule);
            }
          });

          return schedules;
        }

        async function loadStreamSchedules(streamId) {
          try {
            const response = await fetch(`/api/streams/${streamId}/schedules`);
            const data = await response.json();

            if (data.success && data.schedules && data.schedules.length > 0) {
              const container = document.getElementById('editScheduleSlotsContainer');
              container.innerHTML = ''; // Clear existing

              data.schedules.forEach(schedule => {
                // Parse schedule time correctly
                // If it has 'Z' at the end, it's UTC - convert to local
                // If no 'Z', it's already in local format - parse directly
                let scheduleDate;
                
                if (schedule.schedule_time.endsWith('Z')) {
                  // UTC format - JavaScript will auto-convert to local
                  scheduleDate = new Date(schedule.schedule_time);
                } else {
                  // Local format without timezone - parse as-is
                  // Format: "2025-12-16T10:42:00.000"
                  const timePart = schedule.schedule_time.split('T')[1].split('.')[0]; // "10:42:00"
                  const [hour, minute] = timePart.split(':');
                  
                  // Create date with local time
                  scheduleDate = new Date();
                  scheduleDate.setHours(parseInt(hour), parseInt(minute), 0, 0);
                }
                
                const formattedTime = scheduleDate.toTimeString().slice(0, 5); // HH:MM
                
                // Convert duration from minutes to hours and minutes
                const durationMinutes = parseInt(schedule.duration) || 60;
                const hours = Math.floor(durationMinutes / 60);
                const minutes = durationMinutes % 60;
                
                // Calculate end time
                const endTime = new Date(scheduleDate);
                endTime.setMinutes(endTime.getMinutes() + durationMinutes);
                const formattedEndTime = endTime.toTimeString().slice(0, 5);
                
                // Get recurring days
                const recurringDays = schedule.recurring_days ? schedule.recurring_days.split(',') : [];
                const recurringDaysHTML = recurringDays.map(day => `data-selected-day-${day}="true"`).join(' ');

                const slotHTML = `
              <div class="schedule-slot p-3 bg-dark-700/50 rounded-lg border border-gray-600" ${recurringDaysHTML}>
                <div class="flex gap-3 items-start mb-3">
                  <div class="flex-1">
                    <label class="text-xs text-gray-400 mb-1.5 block">Start</label>
                    <input type="time" value="${formattedTime}" class="schedule-time w-full h-[36px] px-3 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary text-sm [color-scheme:dark]" onchange="calculateEditDurationFromEndTime(this)">
                  </div>
                  <div class="flex-1">
                    <label class="text-xs text-gray-400 mb-1.5 block">End</label>
                    <input type="time" value="${formattedEndTime}" class="schedule-endtime w-full h-[36px] px-3 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary text-sm [color-scheme:dark]" onchange="calculateEditDurationFromEndTime(this)">
                  </div>
                  <div class="flex-1">
                    <label class="text-xs text-gray-400 mb-1.5 block">Duration</label>
                    <div class="flex gap-1.5">
                      <input type="number" min="0" max="23" value="${hours}" class="duration-hours w-full h-[36px] px-2 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary text-sm text-center" placeholder="H" onchange="calculateEditFromDuration(this)">
                      <span class="text-sm text-gray-400 flex items-center">:</span>
                      <input type="number" min="0" max="59" value="${minutes}" class="duration-minutes w-full h-[36px] px-2 bg-dark-700 border border-gray-600 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary text-sm text-center" placeholder="M" onchange="calculateEditFromDuration(this)">
                    </div>
                    <input type="hidden" class="schedule-duration" value="${durationMinutes}">
                  </div>
                  <div class="pt-6">
                    <button type="button" onclick="removeEditScheduleSlot(this)" class="h-[36px] w-[36px] flex items-center justify-center bg-red-500/20 hover:bg-red-500/30 text-red-500 border border-red-500/50 rounded-lg transition-colors">
                      <i class="ti ti-trash text-base"></i>
                    </button>
                  </div>
                </div>
                <div class="flex gap-3 items-center flex-wrap">
                  <label class="text-xs text-gray-400 flex-shrink-0">Recurring:</label>
                  <div class="flex gap-1.5 flex-wrap flex-1">
                    <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors ${recurringDays.includes('0') ? 'bg-primary border-primary text-white' : ''}" data-day="0">Sun</button>
                    <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors ${recurringDays.includes('1') ? 'bg-primary border-primary text-white' : ''}" data-day="1">Mon</button>
                    <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors ${recurringDays.includes('2') ? 'bg-primary border-primary text-white' : ''}" data-day="2">Tue</button>
                    <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors ${recurringDays.includes('3') ? 'bg-primary border-primary text-white' : ''}" data-day="3">Wed</button>
                    <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors ${recurringDays.includes('4') ? 'bg-primary border-primary text-white' : ''}" data-day="4">Thu</button>
                    <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors ${recurringDays.includes('5') ? 'bg-primary border-primary text-white' : ''}" data-day="5">Fri</button>
                    <button type="button" class="recurring-day px-2.5 py-1.5 text-xs bg-dark-700 hover:bg-dark-600 border border-gray-600 rounded transition-colors ${recurringDays.includes('6') ? 'bg-primary border-primary text-white' : ''}" data-day="6">Sat</button>
                  </div>
                  <button type="button" onclick="selectAllDaysInEditSlot(this)" class="px-3 py-1.5 text-xs bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors flex-shrink-0">
                    All Days
                  </button>
                </div>
              </div>
            `;
                container.insertAdjacentHTML('beforeend', slotHTML);
              });
              
              attachEditRecurringDayListeners();

              updateEditRemoveButtons();
            } else {
              // No schedules, add one empty slot
              addEditScheduleSlot();
            }
          } catch (error) {
            console.error('Error loading schedules:', error);
            // Add one empty slot on error
            addEditScheduleSlot();
          }
        }
        function updateServerTime() {
          fetch('/api/server-time')
            .then(response => response.json())
            .then(data => {
              if (data.formattedTime) {
                const timeDisplay = `Server time: ${data.formattedTime}`;
                const createModalDisplay = document.getElementById('serverTimeDisplay');
                if (createModalDisplay) {
                  createModalDisplay.textContent = timeDisplay;
                }
                const editModalDisplay = document.getElementById('editServerTimeDisplay');
                if (editModalDisplay) {
                  editModalDisplay.textContent = timeDisplay;
                }
              }
            })
            .catch(error => {
              console.error('Error fetching server time:', error);
            });
        }
        document.addEventListener('DOMContentLoaded', function () {
          updateServerTime();
          // Update every 10 seconds instead of 1 second (save CPU & RAM)
          setInterval(updateServerTime, 10000);
        });
        document.addEventListener('DOMContentLoaded', function () {
          const searchInput = document.querySelector('input[placeholder="Search streams..."]');
          if (searchInput) {
            searchInput.addEventListener('input', function () {
              const searchTerm = this.value.toLowerCase().trim();
              const streamRows = document.querySelectorAll('table tbody tr:not(#empty-state)');
              const streamCards = document.querySelectorAll('.block.md\\:hidden.space-y-4 > div');
              streamRows.forEach(row => {
                const streamTitle = row.querySelector('.text-sm.font-medium')?.textContent.toLowerCase() || '';
                const isMatch = streamTitle.includes(searchTerm);
                row.style.display = isMatch ? '' : 'none';
              });
              streamCards.forEach(card => {
                const streamTitle = card.querySelector('.font-medium')?.textContent.toLowerCase() || '';
                const isMatch = streamTitle.includes(searchTerm);
                card.style.display = isMatch ? '' : 'none';
              });
              const visibleRows = [...streamRows].filter(row => row.style.display !== 'none');
              const visibleCards = [...streamCards].filter(card => card.style.display !== 'none');
              const emptyStateRow = document.getElementById('empty-state');
              if (visibleRows.length === 0 && emptyStateRow) {
                emptyStateRow.style.display = 'table-row';
                const emptyStateMessage = emptyStateRow.querySelector('p.text-gray-500');
                if (emptyStateMessage) {
                  emptyStateMessage.textContent = searchTerm ? 'No streams match your search' : 'Create your first stream to start broadcasting to your audience';
                }
              } else if (emptyStateRow) {
                emptyStateRow.style.display = 'none';
              }
              if (visibleCards.length === 0) {
                const mobileContainer = document.querySelector('.block.md\\:hidden.space-y-4');
                if (mobileContainer && visibleCards.length === 0 && streamCards.length > 0) {
                  const searchMessage = searchTerm ? 'No streams match your search' : 'Create your first stream to start broadcasting';
                  mobileContainer.innerHTML = `
            <div class="bg-gray-800 rounded-lg p-6 text-center">
              <div class="flex flex-col items-center">
                <div class="w-16 h-16 rounded-full bg-dark-700 flex items-center justify-center mb-4">
                  <i class="ti ti-search text-gray-500 text-2xl"></i>
                </div>
                <p class="text-gray-400 font-medium mb-2">${searchMessage}</p>
              </div>
            </div>
          `;
                }
              }
            });
          }
          
          // Initialize recurring day listeners for initial schedule slot
          attachRecurringDayListeners();
        });
      </script>

      <!-- Custom Notification Modal -->
      <div id="notificationModal" class="fixed inset-0 z-[100] hidden">
        <div class="flex min-h-screen items-center justify-center p-4">
          <div class="fixed inset-0 bg-black/60 backdrop-blur-sm" onclick="closeNotification()"></div>
          <div
            class="relative bg-gradient-to-br from-dark-800 to-dark-900 rounded-2xl shadow-2xl w-full max-w-md transform transition-all scale-95 opacity-0"
            id="notificationContent">
            <div class="p-6">
              <div class="flex items-start gap-4">
                <div id="notificationIcon"
                  class="flex-shrink-0 w-12 h-12 rounded-full flex items-center justify-center">
                  <!-- Icon will be inserted here -->
                </div>
                <div class="flex-1 min-w-0">
                  <h3 id="notificationTitle" class="text-lg font-semibold text-white mb-1"></h3>
                  <p id="notificationMessage" class="text-sm text-gray-300"></p>
                </div>
              </div>
              <div class="mt-6 flex justify-end gap-3">
                <button onclick="closeNotification()"
                  class="px-6 py-2.5 bg-primary hover:bg-blue-600 text-white rounded-lg font-medium transition-all transform hover:scale-105 active:scale-95">
                  OK
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Tips Streaming Modal -->
      <div id="tipsStreamingModal" class="fixed inset-0 bg-black/50 z-50 hidden modal-overlay overflow-y-auto">
        <div class="flex min-h-screen items-center justify-center p-4">
          <div class="bg-dark-800 rounded-lg shadow-xl w-full max-w-2xl modal-container">
            <div class="flex items-center justify-between p-4 sm:px-6 sm:py-6 border-b border-gray-700">
              <h3 class="text-lg font-semibold">Tips Streaming</h3>
              <div class="flex items-center gap-2">
                <button onclick="backFromTipsStreaming()"
                  class="flex items-center gap-2 px-3 py-1.5 bg-dark-700 hover:bg-dark-600 text-gray-200 rounded-lg transition-colors">
                  <i class="ti ti-arrow-left"></i>
                  <span class="text-sm">Back</span>
                </button>
                <button onclick="closeTipsStreaming()" class="text-gray-400 hover:text-white">
                  <i class="ti ti-x text-xl"></i>
                </button>
              </div>
            </div>
            <div class="p-4">
              <div class="space-y-3">
                <p class="text-gray-300 text-sm">
                  Agar streaming tetap lancar, rekomendasi export video di bitrate
                  <span
                    class="inline-flex items-center px-2 py-0.5 rounded-md bg-green-600 text-white text-xs font-semibold">2000–3000</span>
                  Kbps.
                </p>
                <div class="rounded-lg border border-gray-700 overflow-hidden">
                  <img src="/images/export-settings.jpg" alt="Contoh pengaturan export video"
                    class="w-full h-auto block">
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <script src="/js/dashboard-stats.js"></script>

      <!-- Stream Templates UI -->
      <%- include('partials/stream-templates-ui') %>