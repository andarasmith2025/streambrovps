<% layout('layout') -%>
<div class="space-y-4">
  <!-- Sticky Header -->
  <div class="sticky top-0 lg:top-0 z-50 bg-dark-900/95 backdrop-blur-sm border-b border-gray-700 -mx-2 sm:-mx-4 md:-mx-6 px-2 sm:px-4 md:px-6 py-3 mb-4">
    <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3">
      <h2 class="text-xl font-semibold">YouTube Broadcasts</h2>
      <div class="flex flex-wrap items-center gap-2 w-full sm:w-auto">
        <!-- Mobile: Show only essential buttons -->
        <div class="hidden sm:flex items-center gap-2">
          <label class="inline-flex items-center gap-2 text-sm text-gray-300">
            <input id="yt-select-all" type="checkbox"> 
            <span class="hidden md:inline">Select all</span>
          </label>
          <button id="yt-bulk-edit" class="px-3 py-1.5 text-sm bg-blue-600 hover:bg-blue-500 rounded disabled:opacity-50" disabled>
            <span class="hidden md:inline">Bulk Edit</span>
            <span class="md:hidden">Edit</span>
          </button>
          <button id="yt-bulk-thumbnail" class="px-3 py-1.5 text-sm bg-purple-600 hover:bg-purple-500 rounded disabled:opacity-50" disabled>
            <span class="hidden md:inline">Bulk Thumbnail</span>
            <span class="md:hidden">Thumb</span>
          </button>
          <button id="yt-bulk-streamkey" class="px-3 py-1.5 text-sm bg-green-600 hover:bg-green-500 rounded disabled:opacity-50" disabled>
            <span class="hidden md:inline">Set Stream Key</span>
            <span class="md:hidden">Key</span>
          </button>
          <button id="yt-bulk-delete" class="px-3 py-1.5 text-sm bg-red-600 hover:bg-red-500 rounded disabled:opacity-50" disabled>
            <span class="hidden md:inline">Delete selected</span>
            <span class="md:hidden">Delete</span>
          </button>
        </div>
        
        <!-- Mobile Bulk Actions Menu -->
        <div class="sm:hidden flex items-center gap-2 w-full">
          <label class="inline-flex items-center gap-2 text-sm text-gray-300">
            <input id="yt-select-all-mobile" type="checkbox"> 
            <span class="text-xs">Select</span>
          </label>
          <button id="mobile-bulk-menu-btn" class="px-3 py-1.5 text-sm bg-gray-700 hover:bg-gray-600 rounded disabled:opacity-50 flex items-center gap-1" disabled>
            <i class="ti ti-dots"></i>
            <span class="text-xs">Actions</span>
          </button>
        </div>
        
        <div class="flex items-center gap-2 ml-auto">
          <button id="yt-refresh-btn" onclick="loadList()" class="p-2 hover:bg-gray-700 rounded transition-colors" title="Refresh">
            <i class="ti ti-refresh text-gray-300"></i>
          </button>
          <select id="yt-status" class="bg-dark-700 border border-gray-600 text-sm rounded px-2 py-1.5">
            <option value="all">All</option>
            <option value="upcoming" selected>Upcoming</option>
            <option value="active">Active</option>
            <option value="completed">Completed</option>
          </select>
        </div>
      </div>
    </div>
    
    <!-- Mobile Bulk Actions Dropdown -->
    <div id="mobile-bulk-menu" class="hidden sm:hidden mt-2 p-2 bg-dark-800 border border-gray-700 rounded-lg space-y-1">
      <button id="yt-bulk-edit-mobile" class="w-full px-3 py-2 text-sm text-left bg-blue-600 hover:bg-blue-500 rounded disabled:opacity-50" disabled>
        <i class="ti ti-edit mr-2"></i>Bulk Edit
      </button>
      <button id="yt-bulk-thumbnail-mobile" class="w-full px-3 py-2 text-sm text-left bg-purple-600 hover:bg-purple-500 rounded disabled:opacity-50" disabled>
        <i class="ti ti-photo mr-2"></i>Bulk Thumbnail
      </button>
      <button id="yt-bulk-streamkey-mobile" class="w-full px-3 py-2 text-sm text-left bg-green-600 hover:bg-green-500 rounded disabled:opacity-50" disabled>
        <i class="ti ti-key mr-2"></i>Set Stream Key
      </button>
      <button id="yt-bulk-delete-mobile" class="w-full px-3 py-2 text-sm text-left bg-red-600 hover:bg-red-500 rounded disabled:opacity-50" disabled>
        <i class="ti ti-trash mr-2"></i>Delete Selected
      </button>
    </div>
  </div>

  <div id="yt-broadcasts" class="space-y-3"></div>

  <!-- Scroll to Top Button -->
  <button id="scrollToTopBtn" class="hidden fixed bottom-20 lg:bottom-6 right-4 lg:right-6 z-40 p-3 bg-primary hover:bg-blue-600 text-white rounded-full shadow-lg transition-all duration-300 hover:scale-110" title="Scroll to top">
    <i class="ti ti-arrow-up text-xl"></i>
  </button>

  <!-- Edit Broadcast Modal -->
  <div id="ytEditModal" class="hidden fixed inset-0 bg-black/50 z-[70] items-center justify-center p-4">
    <div class="bg-dark-800 rounded-xl w-full max-w-md border border-gray-700">
      <div class="p-4 border-b border-gray-700 flex justify-between items-center">
        <h3 class="font-medium">Edit Broadcast</h3>
        <button onclick="closeEditModal()" class="text-gray-400 hover:text-white"><i class="ti ti-x text-xl"></i></button>
      </div>
      <form id="ytEditForm" class="p-4 space-y-4">
        <input type="hidden" id="editBroadcastId">
        <div>
          <label class="block text-sm text-gray-300 mb-1">Title</label>
          <input type="text" id="editTitle" required class="w-full px-3 py-2 bg-dark-700 border border-gray-600 rounded">
        </div>
        <div>
          <label class="block text-sm text-gray-300 mb-1">Description</label>
          <textarea id="editDescription" rows="3" class="w-full px-3 py-2 bg-dark-700 border border-gray-600 rounded"></textarea>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
          <div>
            <label class="block text-sm text-gray-300 mb-1">Scheduled Time</label>
            <input type="datetime-local" id="editScheduledTime" class="w-full px-3 py-2 bg-dark-700 border border-gray-600 rounded">
          </div>
          <div>
            <label class="block text-sm text-gray-300 mb-1">Privacy</label>
            <select id="editPrivacy" class="w-full px-3 py-2 bg-dark-700 border border-gray-600 rounded">
              <option value="private">Private</option>
              <option value="unlisted">Unlisted</option>
              <option value="public">Public</option>
            </select>
          </div>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
          <label class="inline-flex items-center gap-2 text-sm text-gray-300"><input id="editAutoStart" type="checkbox"> Auto Start</label>
          <label class="inline-flex items-center gap-2 text-sm text-gray-300"><input id="editAutoStop" type="checkbox"> Auto End</label>
        </div>
        <div class="pt-2 flex justify-end gap-2">
          <button type="button" onclick="closeEditModal()" class="px-4 py-2 text-sm bg-gray-700 hover:bg-gray-600 rounded">Cancel</button>
          <button type="submit" class="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 rounded">Save</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Bulk Edit Modal -->
  <div id="ytBulkEditModal" class="hidden fixed inset-0 bg-black/50 z-[70] items-center justify-center p-4">
    <div class="bg-dark-800 rounded-xl w-full max-w-2xl border border-gray-700 max-h-[90vh] overflow-y-auto">
      <div class="p-4 border-b border-gray-700 flex justify-between items-center sticky top-0 bg-dark-800 z-10">
        <h3 class="font-medium">Bulk Edit Broadcasts</h3>
        <button onclick="closeBulkEditModal()" class="text-gray-400 hover:text-white"><i class="ti ti-x text-xl"></i></button>
      </div>
      <form id="ytBulkEditForm" class="p-4 space-y-4">
        <div class="bg-blue-900/20 border border-blue-600/30 rounded-lg p-3 mb-4">
          <div class="flex items-start gap-2">
            <i class="ti ti-info-circle text-blue-400 text-lg mt-0.5"></i>
            <div class="text-sm text-gray-300">
              <p class="font-medium mb-1">Editing <span id="bulkEditCount">0</span> broadcasts</p>
              <p class="text-xs text-gray-400">Only filled fields will be updated. Leave fields empty to keep existing values.</p>
            </div>
          </div>
        </div>
        
        <div>
          <label class="block text-sm text-gray-300 mb-1">Title</label>
          <input type="text" id="bulkEditTitle" placeholder="Leave empty to keep existing" class="w-full px-3 py-2 bg-dark-700 border border-gray-600 rounded">
          <p class="text-xs text-gray-500 mt-1">Leave empty to keep each broadcast's current title</p>
        </div>
        
        <div>
          <label class="block text-sm text-gray-300 mb-1">Description</label>
          <textarea id="bulkEditDescription" rows="3" placeholder="Leave empty to keep existing" class="w-full px-3 py-2 bg-dark-700 border border-gray-600 rounded"></textarea>
          <p class="text-xs text-gray-500 mt-1">Leave empty to keep each broadcast's current description</p>
        </div>
        
        <div>
          <label class="block text-sm text-gray-300 mb-1">Privacy</label>
          <select id="bulkEditPrivacy" class="w-full px-3 py-2 bg-dark-700 border border-gray-600 rounded">
            <option value="">Keep existing</option>
            <option value="private">Private</option>
            <option value="unlisted">Unlisted</option>
            <option value="public">Public</option>
          </select>
        </div>
        
        <div class="border-t border-gray-700 pt-4">
          <label class="block text-sm font-medium text-white mb-3">Additional Settings</label>
          
          <div class="space-y-3">
            <div>
              <label class="block text-sm text-gray-300 mb-2">Made for Kids</label>
              <div class="flex items-center gap-4">
                <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                  <input type="radio" name="bulkMadeForKids" value="" checked class="w-4 h-4">
                  <span>Keep existing</span>
                </label>
                <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                  <input type="radio" name="bulkMadeForKids" value="yes" class="w-4 h-4">
                  <span>Yes</span>
                </label>
                <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                  <input type="radio" name="bulkMadeForKids" value="no" class="w-4 h-4">
                  <span>No</span>
                </label>
              </div>
            </div>
            
            <div>
              <label class="block text-sm text-gray-300 mb-2">Age Restriction</label>
              <div class="flex items-center gap-4">
                <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                  <input type="radio" name="bulkAgeRestricted" value="" checked class="w-4 h-4">
                  <span>Keep existing</span>
                </label>
                <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                  <input type="radio" name="bulkAgeRestricted" value="yes" class="w-4 h-4">
                  <span>Age-restricted (18+)</span>
                </label>
                <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                  <input type="radio" name="bulkAgeRestricted" value="no" class="w-4 h-4">
                  <span>Not restricted</span>
                </label>
              </div>
            </div>
            
            <div>
              <label class="block text-sm text-gray-300 mb-2">Synthetic Content</label>
              <div class="flex items-center gap-4">
                <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                  <input type="radio" name="bulkSyntheticContent" value="" checked class="w-4 h-4">
                  <span>Keep existing</span>
                </label>
                <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                  <input type="radio" name="bulkSyntheticContent" value="yes" class="w-4 h-4">
                  <span>Contains AI content</span>
                </label>
                <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                  <input type="radio" name="bulkSyntheticContent" value="no" class="w-4 h-4">
                  <span>No AI content</span>
                </label>
              </div>
            </div>
            
            <!-- Auto Start/Stop removed from bulk edit due to YouTube API strict requirements -->
            <!-- Use individual edit (Edit button) to change these settings -->
          </div>
        </div>
        
        <div id="bulkEditProgress" class="hidden bg-gray-900/50 border border-gray-700 rounded-lg p-3">
          <div class="flex items-center gap-2 mb-2">
            <i class="ti ti-loader animate-spin text-blue-400"></i>
            <span class="text-sm text-gray-300">Processing...</span>
          </div>
          <div class="text-xs text-gray-400" id="bulkEditProgressText">0 / 0 completed</div>
        </div>
        
        <div class="pt-2 flex justify-end gap-2 border-t border-gray-700">
          <button type="button" onclick="closeBulkEditModal()" class="px-4 py-2 text-sm bg-gray-700 hover:bg-gray-600 rounded">Cancel</button>
          <button type="submit" class="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 rounded">Apply Changes</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Bulk Stream Key Modal -->
  <div id="ytBulkStreamKeyModal" class="hidden fixed inset-0 bg-black/50 z-[70] items-center justify-center p-4">
    <div class="bg-dark-800 rounded-xl w-full max-w-3xl border border-gray-700 max-h-[90vh] overflow-y-auto">
      <div class="p-4 border-b border-gray-700 flex justify-between items-center sticky top-0 bg-dark-800 z-10">
        <h3 class="font-medium">Set Stream Key</h3>
        <button onclick="closeBulkStreamKeyModal()" class="text-gray-400 hover:text-white"><i class="ti ti-x text-xl"></i></button>
      </div>
      <div class="p-4">
        <div class="bg-green-900/20 border border-green-600/30 rounded-lg p-3 mb-4">
          <div class="flex items-start gap-2">
            <i class="ti ti-info-circle text-green-400 text-lg mt-0.5"></i>
            <div class="text-sm text-gray-300">
              <p class="font-medium mb-1">Binding stream key to <span id="bulkStreamKeyCount">0</span> broadcasts</p>
              <p class="text-xs text-gray-400">Select a stream key below to bind to all selected broadcasts</p>
            </div>
          </div>
        </div>
        
        <div class="space-y-2 mb-4" id="streamKeyList">
          <!-- Stream cards will be inserted here -->
        </div>
        
        <div id="bulkStreamKeyProgress" class="hidden bg-gray-900/50 border border-gray-700 rounded-lg p-3 mb-4">
          <div class="flex items-center gap-2 mb-2">
            <i class="ti ti-loader animate-spin text-green-400"></i>
            <span class="text-sm text-gray-300">Binding stream keys...</span>
          </div>
          <div class="text-xs text-gray-400" id="bulkStreamKeyProgressText">0 / 0 completed</div>
        </div>
        
        <div class="pt-2 flex justify-end gap-2 border-t border-gray-700">
          <button type="button" onclick="closeBulkStreamKeyModal()" class="px-4 py-2 text-sm bg-gray-700 hover:bg-gray-600 rounded">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  
</div>

<!-- Duplicate Broadcast Modal -->
<div id="ytDuplicateModal" class="hidden fixed inset-0 bg-black/50 z-[70] items-center justify-center p-4">
  <div class="bg-dark-800 rounded-xl w-full max-w-md border border-gray-700">
    <div class="p-4 border-b border-gray-700 flex justify-between items-center">
      <h3 class="font-medium">Duplicate Broadcast</h3>
      <button onclick="closeDuplicateModal()" class="text-gray-400 hover:text-white"><i class="ti ti-x text-xl"></i></button>
    </div>
    <form onsubmit="submitDuplicate(event)" class="p-4 space-y-4">
      <input type="hidden" id="dupSourceId">
      <div>
        <label class="block text-sm text-gray-300 mb-1">Tanggal & Waktu</label>
        <input id="dupDateTime" type="datetime-local" required class="w-full px-3 py-2 bg-dark-700 border border-gray-600 rounded" />
      </div>
      <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
        <label class="inline-flex items-center gap-2 text-sm text-gray-300"><input id="dupRepeatDaily" type="checkbox"> Ulangi Harian</label>
        <div class="flex items-center gap-2">
          <label class="text-sm text-gray-300">Jumlah Hari</label>
          <input id="dupDays" type="number" min="1" value="7" class="w-20 px-2 py-2 bg-dark-700 border border-gray-600 rounded" />
        </div>
      </div>
      <div id="dupProgress" class="text-sm text-gray-400 hidden"></div>
      <div class="pt-2 flex justify-end gap-2">
        <button id="dupCancelBtn" type="button" onclick="closeDuplicateModal()" class="px-4 py-2 text-sm bg-gray-700 hover:bg-gray-600 rounded">Cancel</button>
        <button id="dupSubmitBtn" type="submit" class="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-500 rounded">Duplicate</button>
      </div>
    </form>
  </div>
  </div>

<script>
  const ytThumbBust = {};
  function withCacheBust(url, id){
    if (!url) return url;
    const bust = ytThumbBust[id];
    if (!bust) return url;
    const sep = url.includes('?') ? '&' : '?';
    return url + sep + 'cb=' + bust;
  }
  async function fetchBroadcasts(){
    const statusSel = document.getElementById('yt-status');
    const status = statusSel ? statusSel.value : 'upcoming';
    const res = await fetch('/youtube/api/broadcasts?status=' + encodeURIComponent(status), { cache: 'no-store' });
    const data = await res.json();
    if (!res.ok) throw new Error(data.message || data.error || 'Failed to fetch');
    return data.items || [];
  }
  function renderItem(item){
    const el = document.createElement('div');
    el.className = 'bg-dark-800 border border-gray-700 rounded-lg p-3 flex flex-col sm:flex-row gap-3';
    const title = item.snippet?.title || '';
    const privacy = item.status?.privacyStatus || 'private';
    const rawThumb = item.snippet?.thumbnails?.medium?.url || item.snippet?.thumbnails?.default?.url || '';
    const thumb = withCacheBust(rawThumb, item.id);
    const when = item.snippet?.scheduledStartTime || '';
    const life = (item.status?.lifeCycleStatus||'').toLowerCase();
    const schedIso = item.snippet?.scheduledStartTime || '';
    const canLive = ['created','ready','testing','teststarting','livestarting'].includes(life);
    const canComplete = ['live','testing','livestarting','teststarting'].includes(life);
    el.innerHTML = `
      <div class="flex items-center gap-3 sm:gap-4 w-full">
        <label class="self-start mt-1"><input type="checkbox" class="yt-select-item" value="${item.id}"></label>
        ${thumb ? `<img src="${thumb}" class="w-36 h-20 object-cover rounded border border-gray-700 flex-shrink-0"/>` : ''}
        <div class="min-w-0 flex-1">
          <div class="font-medium truncate">${title}</div>
          <div class="text-xs text-gray-400 mt-1 flex gap-3 flex-wrap">
            <span title="Scheduled"><i class="ti ti-clock mr-1"></i>${when || '-'}</span>
            <span title="Privacy"><i class="ti ti-lock mr-1"></i>${privacy}</span>
            <span title="Lifecycle" class="px-1.5 py-0.5 rounded ${life==='live'?'bg-red-900/50 text-red-300':(life==='testing'?'bg-yellow-900/50 text-yellow-300':'bg-gray-700/50 text-gray-300')}"><i class="ti ti-activity mr-1"></i>${life || '-'}</span>
            <span title="ID" class="truncate max-w-[12rem]"><i class="ti ti-hash mr-1"></i>${item.id}</span>
          </div>
          <div class="mt-1 hidden text-xs text-gray-300 gap-4 flex-wrap" id="metrics-${item.id}">
            <span><i class="ti ti-eye mr-1"></i><span class="m-viewers">0</span> viewers</span>
            <span><i class="ti ti-thumb-up mr-1"></i><span class="m-likes">0</span> likes</span>
            <span><i class="ti ti-message-2 mr-1"></i><span class="m-comments">0</span> comments</span>
          </div>
        </div>
      </div>
      <div class="flex flex-wrap sm:flex-nowrap items-center gap-2 sm:ml-auto md:ml-8 shrink-0 w-full sm:w-auto justify-end whitespace-nowrap">
        <button class="p-2 hover:bg-gray-700 rounded" title="Edit" 
                onclick="openEditFromData(this)"
                data-id="${item.id}"
                data-title="${(item.snippet?.title||'').replace(/&/g,'&amp;').replace(/\"/g,'&quot;')}"
                data-description="${(item.snippet?.description||'').replace(/&/g,'&amp;').replace(/\"/g,'&quot;')}"
                data-when="${when}"
                data-privacy="${privacy}"
                data-autostart="${item.contentDetails?.enableAutoStart ? '1':'0'}"
                data-autostop="${item.contentDetails?.enableAutoStop ? '1':'0'}">
          <i class="ti ti-edit text-blue-400"></i>
        </button>
        <button class="p-2 hover:bg-gray-700 rounded" title="Duplicate" onclick="openDuplicateModal('${item.id}', '${schedIso}')">
          <i class="ti ti-copy text-gray-300"></i>
        </button>
        <button class="p-2 hover:bg-gray-700 rounded" title="Thumbnail" onclick="uploadThumbnail('${item.id}')">
          <i class="ti ti-photo text-purple-300"></i>
        </button>
        <button class="p-2 hover:bg-gray-700 rounded" title="Delete" onclick="deleteBroadcast('${item.id}')">
          <i class="ti ti-trash text-red-300"></i>
        </button>
        <div class="h-5 w-px bg-gray-600 mx-1"></div>
        <button class="h-9 px-4 text-sm font-medium rounded ${canLive ? 'bg-green-600 hover:bg-green-500' : 'bg-green-900/30 text-green-500/50 cursor-not-allowed'} min-w-[96px]" ${canLive ? '' : 'disabled'} onclick="transitionBroadcast('${item.id}','live')">Go Live</button>
        <button class="h-8 px-3 text-xs rounded ${canComplete ? 'bg-red-600 hover:bg-red-500' : 'bg-red-900/30 text-red-500/50 cursor-not-allowed'}" ${canComplete ? '' : 'disabled'} onclick="transitionBroadcast('${item.id}','complete')">End</button>
      </div>`;
    return el;
  }
  async function loadList(){
    const container = document.getElementById('yt-broadcasts');
    container.innerHTML = '<div class="text-gray-400">Loading...</div>';
    try {
      const items = await fetchBroadcasts();
      container.innerHTML = '';
      if (!items.length){
        const statusSel = document.getElementById('yt-status');
        const status = statusSel ? statusSel.value : 'upcoming';
        const wrap = document.createElement('div');
        wrap.className = 'text-gray-300';
        wrap.innerHTML = `
          <div class="text-gray-400">No ${status} broadcasts.</div>
          <button id="yt-show-raw" class="mt-2 px-3 py-1.5 bg-gray-700 hover:bg-gray-600 rounded text-sm">Show raw (debug)</button>
          <div id="yt-raw" class="mt-2 text-xs text-gray-400"></div>
        `;
        container.appendChild(wrap);
        const btn = document.getElementById('yt-show-raw');
        const rawDiv = document.getElementById('yt-raw');
        if (btn) btn.addEventListener('click', async ()=>{
          try {
            const res = await fetch('/youtube/api/broadcasts?status=' + encodeURIComponent(status) + '&debug=1');
            const data = await res.json();
            const arr = data.items || [];
            rawDiv.innerHTML = arr.map(i => `${i.id} :: ${(i.snippet?.title)||''} :: ${(i.status?.lifeCycleStatus)||''}`).join('<br>') || '(empty)';
          } catch { rawDiv.textContent = 'debug failed'; }
        });
        return;
      }
      items.forEach(it=>container.appendChild(renderItem(it)));

      // If viewing Active, fetch metrics and populate
      const statusSel = document.getElementById('yt-status');
      const status = statusSel ? statusSel.value : 'upcoming';
      if (String(status).toLowerCase() === 'active' && items.length) {
        try {
          const ids = items.map(i=>i.id).join(',');
          const res = await fetch('/youtube/api/metrics?ids=' + encodeURIComponent(ids));
          const data = await res.json();
          const map = data.items || {};
          items.forEach(i => {
            const row = document.getElementById('metrics-' + i.id);
            const m = map[i.id];
            if (row && m) {
              row.classList.remove('hidden');
              const v = row.querySelector('.m-viewers');
              const l = row.querySelector('.m-likes');
              const c = row.querySelector('.m-comments');
              if (v) v.textContent = m.viewers ?? 0;
              if (l) l.textContent = m.likeCount ?? 0;
              if (c) c.textContent = m.commentCount ?? 0;
            }
          });
        } catch {}
      }
    } catch (e){
      const errorMsg = e?.message || 'Unknown error';
      
      // Check if error indicates need to reconnect
      if (errorMsg.includes('reconnect') || errorMsg.includes('not connected') || errorMsg.includes('invalid')) {
        container.innerHTML = `
          <div class="bg-yellow-900/20 border border-yellow-600/30 rounded-lg p-4">
            <div class="flex items-start gap-3">
              <i class="ti ti-alert-triangle text-yellow-400 text-2xl"></i>
              <div class="flex-1">
                <div class="font-medium text-yellow-300 mb-2">YouTube Connection Required</div>
                <div class="text-sm text-gray-300 mb-3">${errorMsg}</div>
                <div class="flex gap-2">
                  <a href="/oauth2/disconnect" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded text-sm transition-colors">
                    <i class="ti ti-plug-off mr-1"></i>Disconnect
                  </a>
                  <a href="/oauth2/login" class="px-4 py-2 bg-primary hover:bg-blue-600 text-white rounded text-sm transition-colors">
                    <i class="ti ti-brand-youtube mr-1"></i>Reconnect YouTube
                  </a>
                  <a href="/dashboard" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded text-sm transition-colors">
                    <i class="ti ti-arrow-left mr-1"></i>Back to Dashboard
                  </a>
                </div>
              </div>
            </div>
          </div>
        `;
      } else {
        container.innerHTML = `<div class="text-red-400">Failed to load broadcasts: ${errorMsg}</div>`;
      }
    }
  }
  function openEditFromData(btn){
    const id = btn?.dataset?.id || '';
    const title = btn?.dataset?.title || '';
    const description = btn?.dataset?.description || '';
    const when = btn?.dataset?.when || '';
    const privacy = btn?.dataset?.privacy || 'private';
    const autoStart = btn?.dataset?.autostart === '1';
    const autoStop = btn?.dataset?.autostop === '1';
    const modal = document.getElementById('ytEditModal');
    document.getElementById('editBroadcastId').value = id;
    document.getElementById('editTitle').value = title;
    document.getElementById('editDescription').value = description;
    document.getElementById('editPrivacy').value = privacy;
    const chkStart = document.getElementById('editAutoStart');
    const chkStop = document.getElementById('editAutoStop');
    if (chkStart) chkStart.checked = !!autoStart;
    if (chkStop) chkStop.checked = !!autoStop;
    if (when) {
      try {
        const d = new Date(when);
        document.getElementById('editScheduledTime').value = new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString().slice(0,16);
      } catch {}
    } else {
      document.getElementById('editScheduledTime').value = '';
    }
    modal.classList.remove('hidden');
    modal.classList.add('flex');
  }
  function closeEditModal(){
    const modal = document.getElementById('ytEditModal');
    modal.classList.add('hidden');
    modal.classList.remove('flex');
  }
  // old duplicate prompt removed; use modal instead
  function transitionBroadcast(id, status){
    // Show loading state
    const button = event?.target;
    const originalText = button?.textContent;
    if (button) {
      button.disabled = true;
      button.textContent = status === 'live' ? 'Going Live...' : 'Ending...';
    }
    
    fetch(`/youtube/broadcasts/${id}/transition`, { 
      method:'POST', 
      headers:{'Content-Type':'application/json'}, 
      body: JSON.stringify({ status })
    })
      .then(r=>r.json()).then(d=>{
        if (d.error) throw new Error(d.details || d.error);
        toast(`Transitioned to ${status}`, 'success');
        loadList();
      }).catch(e=>{
        console.error('Transition error:', e);
        const errorMsg = e.message || 'Unknown error';
        
        // Show user-friendly error message
        if (errorMsg.includes('Stream not active')) {
          toast('Stream not active - Please start your streaming software first', 'error');
        } else if (errorMsg.includes('No stream bound')) {
          toast('No stream key bound to this broadcast', 'error');
        } else if (errorMsg.includes('Invalid transition') || errorMsg.includes('not in the right state')) {
          toast('Cannot transition - Broadcast not ready or stream inactive', 'error');
        } else {
          toast(`Transition failed: ${errorMsg}`, 'error');
        }
      }).finally(() => {
        // Restore button state
        if (button && originalText) {
          button.disabled = false;
          button.textContent = originalText;
        }
      });
  }
  function uploadThumbnail(id){
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = async () => {
      if (!input.files || !input.files[0]) return;
      const fd = new FormData();
      fd.append('file', input.files[0]);
      try {
        const res = await fetch(`/youtube/broadcasts/${id}/thumbnail`, { method:'POST', body: fd });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || 'Upload failed');
        ytThumbBust[id] = Date.now();
        toast('Thumbnail updated', 'success');
        loadList();
      } catch (e){
        toast('Thumbnail failed: '+(e.message||'Error'), 'error');
      }
    };
    input.click();
  }
  function copyText(text){
    navigator.clipboard.writeText(text).then(()=>toast('Copied','success')).catch(()=>toast('Copy failed','error'));
  }
  // Duplicate Modal logic
  function openDuplicateModal(id, iso){
    const m = document.getElementById('ytDuplicateModal');
    if (!m) return;
    document.getElementById('dupSourceId').value = id;
    const inp = document.getElementById('dupDateTime');
    try {
      if (iso) {
        const dt = new Date(iso);
        const local = new Date(dt.getTime()-dt.getTimezoneOffset()*60000).toISOString().slice(0,16);
        inp.value = local;
      } else {
        const now = new Date();
        const local = new Date(now.getTime()-now.getTimezoneOffset()*60000).toISOString().slice(0,16);
        inp.value = local;
      }
    } catch {}
    m.classList.remove('hidden');
    m.classList.add('flex');
  }
  function closeDuplicateModal(){
    const m = document.getElementById('ytDuplicateModal');
    if (!m) return;
    m.classList.add('hidden');
    m.classList.remove('flex');
  }
  async function submitDuplicate(e){
    e?.preventDefault();
    const id = document.getElementById('dupSourceId').value;
    const dtVal = document.getElementById('dupDateTime').value;
    const repeat = document.getElementById('dupRepeatDaily').checked;
    const days = parseInt(document.getElementById('dupDays').value || '1', 10);
    if (!id || !dtVal) { toast('Please set date & time','error'); return; }
    const base = new Date(dtVal);
    const tasks = Math.max(1, repeat ? days : 1);
    const btnSubmit = document.getElementById('dupSubmitBtn');
    const btnCancel = document.getElementById('dupCancelBtn');
    const prog = document.getElementById('dupProgress');
    if (btnSubmit) btnSubmit.disabled = true;
    if (btnCancel) btnCancel.disabled = true;
    if (btnSubmit) btnSubmit.classList.add('opacity-60');
    if (btnCancel) btnCancel.classList.add('opacity-60');
    if (prog) { prog.classList.remove('hidden'); prog.textContent = `Memulai duplicate 0/${tasks}...`; }
    try {
      let okCount = 0, skipCount = 0, failCount = 0;
      for (let i=0;i<tasks;i++){
        const t = new Date(base);
        t.setDate(base.getDate()+i);
        const iso = t.toISOString();
        // Skip jika waktu kurang dari now + 2 menit
        const now = new Date();
        if (t.getTime() < now.getTime() + 2*60*1000) { skipCount++; if (prog) prog.textContent = `Lewati ${i+1}/${tasks} (terlalu dekat/masa lalu).`; continue; }
        const res = await fetch(`/youtube/broadcasts/${id}/duplicate`,{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ scheduledStartTime: iso })});
        const data = await res.json();
        if (!res.ok || data.error) { failCount++; if (prog) prog.textContent = `Gagal ${i+1}/${tasks}: ${data.error||'Duplicate failed'}`; continue; }
        okCount++;
        if (prog) prog.textContent = `Berhasil ${okCount}, Lewati ${skipCount}, Gagal ${failCount} — progress ${i+1}/${tasks}`;
      }
      toast(`Duplicate selesai — Berhasil ${okCount}, Lewati ${skipCount}, Gagal ${failCount}`,'success');
      closeDuplicateModal();
      loadList();
    } catch(err){
      toast('Duplicate failed: ' + (err.message||'Error'),'error');
    }
    finally {
      if (btnSubmit) { btnSubmit.disabled = false; btnSubmit.classList.remove('opacity-60'); }
      if (btnCancel) { btnCancel.disabled = false; btnCancel.classList.remove('opacity-60'); }
    }
  }
  async function deleteBroadcast(id){
    try{
      const ok = confirm('Delete this broadcast? This cannot be undone.');
      if (!ok) return;
      const res = await fetch(`/youtube/broadcasts/${id}`, { method: 'DELETE' });
      const data = await res.json().catch(()=>({}));
      if (!res.ok || data.error) throw new Error(data.error || 'Delete failed');
      toast('Broadcast deleted','success');
      loadList();
    } catch(err){
      toast('Failed to delete: ' + (err.message || 'Error'), 'error');
    }
  }
  document.addEventListener('DOMContentLoaded', ()=>{ 
    const statusSel = document.getElementById('yt-status');
    if (statusSel) statusSel.addEventListener('change', loadList);
    
    // Initial load
    loadList();
    
    // Auto-refresh every 60 seconds (reduced from 30s since token management is stable)
    // Pause when modal is open to prevent interrupting user edits
    let autoRefreshInterval = setInterval(() => {
      // Check if any modal is open
      const editModalOpen = !document.getElementById('ytEditModal').classList.contains('hidden');
      const bulkEditModalOpen = !document.getElementById('ytBulkEditModal').classList.contains('hidden');
      const bulkStreamKeyModalOpen = !document.getElementById('ytBulkStreamKeyModal').classList.contains('hidden');
      const duplicateModalOpen = !document.getElementById('ytDuplicateModal').classList.contains('hidden');
      
      if (editModalOpen || bulkEditModalOpen || bulkStreamKeyModalOpen || duplicateModalOpen) {
        console.log('[YouTube Manage] Skipping auto-refresh - modal is open');
        return;
      }
      
      console.log('[YouTube Manage] Auto-refreshing broadcasts...');
      loadList();
    }, 60000); // 60 seconds (1 minute)
    
    // Listen for custom event from dashboard (when stream created)
    window.addEventListener('youtubeStreamCreated', () => {
      console.log('[YouTube Manage] Stream created, refreshing list...');
      loadList();
    });
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
      }
    }); 
    // Bulk selection controls
    const selAll = document.getElementById('yt-select-all');
    const bulkBtn = document.getElementById('yt-bulk-delete');
    function refreshBulkState(){
      const boxes = Array.from(document.querySelectorAll('.yt-select-item'));
      const any = boxes.some(b=>b.checked);
      const bulkEditBtn = document.getElementById('yt-bulk-edit');
      const bulkThumbBtn = document.getElementById('yt-bulk-thumbnail');
      const bulkStreamKeyBtn = document.getElementById('yt-bulk-streamkey');
      if (bulkBtn) bulkBtn.disabled = !any;
      if (bulkEditBtn) bulkEditBtn.disabled = !any;
      if (bulkThumbBtn) bulkThumbBtn.disabled = !any;
      if (bulkStreamKeyBtn) bulkStreamKeyBtn.disabled = !any;
      if (selAll) selAll.checked = boxes.length>0 && boxes.every(b=>b.checked);
    }
    if (selAll) selAll.addEventListener('change', ()=>{
      const boxes = document.querySelectorAll('.yt-select-item');
      boxes.forEach(b=>b.checked = selAll.checked);
      refreshBulkState();
    });
    document.addEventListener('change', (e)=>{
      if (e.target && e.target.classList && e.target.classList.contains('yt-select-item')){
        refreshBulkState();
      }
    });
    if (bulkBtn) bulkBtn.addEventListener('click', async ()=>{
      const ids = Array.from(document.querySelectorAll('.yt-select-item:checked')).map(b=>b.value);
      if (!ids.length) return;
      if (!confirm(`Delete ${ids.length} selected broadcasts? This cannot be undone.`)) return;
      bulkBtn.disabled = true; if (selAll) selAll.disabled = true;
      let ok=0, fail=0; 
      for (let i=0;i<ids.length;i++){
        try{
          const res = await fetch(`/youtube/broadcasts/${ids[i]}`, { method:'DELETE' });
          if (!res.ok) throw new Error('delete failed');
          ok++;
        } catch { fail++; }
      }
      toast(`Bulk delete done — Success ${ok}, Failed ${fail}`, fail? 'error':'success');
      if (selAll) { selAll.disabled = false; selAll.checked = false; }
      bulkBtn.disabled = false;
      loadList();
    });
    
    // Bulk Edit button
    const bulkEditBtn = document.getElementById('yt-bulk-edit');
    if (bulkEditBtn) bulkEditBtn.addEventListener('click', ()=>{
      const ids = Array.from(document.querySelectorAll('.yt-select-item:checked')).map(b=>b.value);
      if (!ids.length) return;
      openBulkEditModal(ids);
    });
    
    // Bulk Thumbnail button
    const bulkThumbBtn = document.getElementById('yt-bulk-thumbnail');
    if (bulkThumbBtn) bulkThumbBtn.addEventListener('click', ()=>{
      const ids = Array.from(document.querySelectorAll('.yt-select-item:checked')).map(b=>b.value);
      if (!ids.length) return;
      openBulkThumbnailUpload(ids);
    });
    
    // Bulk Stream Key button
    const bulkStreamKeyBtn = document.getElementById('yt-bulk-streamkey');
    if (bulkStreamKeyBtn) bulkStreamKeyBtn.addEventListener('click', async ()=>{
      const ids = Array.from(document.querySelectorAll('.yt-select-item:checked')).map(b=>b.value);
      if (!ids.length) return;
      
      // Get list of available streams
      try {
        const res = await fetch('/youtube/api/streams');
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || 'Failed to fetch streams');
        
        const streams = data.items || [];
        if (!streams.length) {
          toast('No stream keys available. Create a stream first.', 'error');
          return;
        }
        
        // Open modal with stream selection
        openBulkStreamKeyModal(ids, streams);
      } catch (err) {
        toast('Failed to load streams: ' + err.message, 'error');
      }
    });
  
    const editForm = document.getElementById('ytEditForm');
    if (editForm) {
      editForm.addEventListener('submit', async (e)=>{
        e.preventDefault();
        const id = document.getElementById('editBroadcastId').value;
        const title = document.getElementById('editTitle').value;
        const description = document.getElementById('editDescription').value;
        const privacyStatus = document.getElementById('editPrivacy').value;
        const dt = document.getElementById('editScheduledTime').value;
        const enableAutoStart = !!document.getElementById('editAutoStart')?.checked;
        const enableAutoStop = !!document.getElementById('editAutoStop')?.checked;
        const body = { title, description, privacyStatus };
        if (dt) {
          try { body.scheduledStartTime = new Date(dt).toISOString(); } catch {}
        }
        body.enableAutoStart = enableAutoStart;
        body.enableAutoStop = enableAutoStop;
        try {
          const res = await fetch(`/youtube/broadcasts/${id}`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
          const data = await res.json();
          if (!res.ok || data.error) throw new Error(data.error || 'Update failed');
          toast('Broadcast updated','success');
          closeEditModal();
          loadList();
        } catch (err){
          toast('Update failed: '+(err.message||'Error'),'error');
        }
      });
    }
  });
  
  // Bulk Edit Modal Functions
  function openBulkEditModal(ids){
    const modal = document.getElementById('ytBulkEditModal');
    const countSpan = document.getElementById('bulkEditCount');
    if (countSpan) countSpan.textContent = ids.length;
    
    // Store selected IDs in modal
    modal.dataset.selectedIds = JSON.stringify(ids);
    
    // Reset form
    document.getElementById('bulkEditTitle').value = '';
    document.getElementById('bulkEditDescription').value = '';
    document.getElementById('bulkEditPrivacy').value = '';
    
    // Reset radio buttons to "keep existing"
    document.querySelectorAll('input[name="bulkMadeForKids"]').forEach(r => r.checked = r.value === '');
    document.querySelectorAll('input[name="bulkAgeRestricted"]').forEach(r => r.checked = r.value === '');
    document.querySelectorAll('input[name="bulkSyntheticContent"]').forEach(r => r.checked = r.value === '');
    
    modal.classList.remove('hidden');
    modal.classList.add('flex');
  }
  
  function closeBulkEditModal(){
    const modal = document.getElementById('ytBulkEditModal');
    modal.classList.add('hidden');
    modal.classList.remove('flex');
  }
  
  // Bulk Edit Form Submit
  const bulkEditForm = document.getElementById('ytBulkEditForm');
  if (bulkEditForm) {
    bulkEditForm.addEventListener('submit', async (e)=>{
      e.preventDefault();
      
      const modal = document.getElementById('ytBulkEditModal');
      const ids = JSON.parse(modal.dataset.selectedIds || '[]');
      if (!ids.length) return;
      
      // Collect updates (only include fields that should be updated)
      const updates = {};
      
      const title = document.getElementById('bulkEditTitle').value.trim();
      if (title) updates.title = title;
      
      const description = document.getElementById('bulkEditDescription').value.trim();
      if (description) updates.description = description;
      
      const privacy = document.getElementById('bulkEditPrivacy').value;
      if (privacy) updates.privacyStatus = privacy;
      
      // Additional settings
      const madeForKids = document.querySelector('input[name="bulkMadeForKids"]:checked')?.value;
      if (madeForKids) updates.selfDeclaredMadeForKids = madeForKids === 'yes';
      
      const ageRestricted = document.querySelector('input[name="bulkAgeRestricted"]:checked')?.value;
      if (ageRestricted) updates.ageRestricted = ageRestricted === 'yes';
      
      const syntheticContent = document.querySelector('input[name="bulkSyntheticContent"]:checked')?.value;
      if (syntheticContent) updates.syntheticContent = syntheticContent === 'yes';
      
      // Auto Start/Stop removed from bulk edit due to YouTube API strict requirements
      // Use individual edit (Edit button) to change these settings
      
      // Check if any updates
      if (Object.keys(updates).length === 0) {
        toast('No changes to apply', 'info');
        return;
      }
      
      // Show progress
      const progress = document.getElementById('bulkEditProgress');
      const progressText = document.getElementById('bulkEditProgressText');
      const submitBtn = bulkEditForm.querySelector('button[type="submit"]');
      const cancelBtn = bulkEditForm.querySelector('button[type="button"]');
      
      if (progress) progress.classList.remove('hidden');
      if (submitBtn) submitBtn.disabled = true;
      if (cancelBtn) cancelBtn.disabled = true;
      
      let success = 0, failed = 0;
      
      for (let i = 0; i < ids.length; i++) {
        const id = ids[i];
        if (progressText) progressText.textContent = `${i + 1} / ${ids.length} processing...`;
        
        try {
          const res = await fetch(`/youtube/broadcasts/${id}/bulk-update`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updates)
          });
          
          const data = await res.json();
          if (!res.ok || data.error) throw new Error(data.error || 'Update failed');
          success++;
        } catch (err) {
          console.error(`Failed to update ${id}:`, err.message);
          failed++;
        }
      }
      
      if (progress) progress.classList.add('hidden');
      if (submitBtn) submitBtn.disabled = false;
      if (cancelBtn) cancelBtn.disabled = false;
      
      toast(`Bulk edit complete — Success: ${success}, Failed: ${failed}`, failed > 0 ? 'error' : 'success');
      
      closeBulkEditModal();
      
      // Uncheck all and refresh
      const selAll = document.getElementById('yt-select-all');
      if (selAll) selAll.checked = false;
      document.querySelectorAll('.yt-select-item').forEach(b => b.checked = false);
      
      loadList();
    });
  }
  
  // Bulk Stream Key Modal Functions
  function openBulkStreamKeyModal(ids, streams){
    const modal = document.getElementById('ytBulkStreamKeyModal');
    const countSpan = document.getElementById('bulkStreamKeyCount');
    if (countSpan) countSpan.textContent = ids.length;
    
    // Store selected IDs in modal
    modal.dataset.selectedIds = JSON.stringify(ids);
    
    // Render stream cards
    const streamKeyList = document.getElementById('streamKeyList');
    streamKeyList.innerHTML = streams.map((stream, index) => `
      <div class="stream-key-card border border-gray-700 rounded-lg p-4 hover:border-green-500 hover:bg-green-900/10 cursor-pointer transition-all" 
           onclick="selectStreamKey('${stream.id}', ${index + 1})">
        <div class="flex items-center justify-between">
          <div class="flex-1">
            <div class="flex items-center gap-2 mb-1">
              <span class="text-lg font-medium text-white">${index + 1}</span>
              <i class="ti ti-key text-green-400"></i>
              <span class="font-medium text-white">${stream.title || 'Untitled Stream'}</span>
            </div>
            <div class="flex items-center gap-2 text-sm text-gray-400">
              <i class="ti ti-shield-lock text-xs"></i>
              <code class="bg-dark-700 px-2 py-1 rounded text-xs font-mono">${stream.streamKeyMasked || stream.id}</code>
            </div>
          </div>
          <i class="ti ti-chevron-right text-gray-500"></i>
        </div>
      </div>
    `).join('');
    
    modal.classList.remove('hidden');
    modal.classList.add('flex');
  }
  
  function closeBulkStreamKeyModal(){
    const modal = document.getElementById('ytBulkStreamKeyModal');
    modal.classList.add('hidden');
    modal.classList.remove('flex');
  }
  
  async function selectStreamKey(streamId, streamNumber){
    const modal = document.getElementById('ytBulkStreamKeyModal');
    const ids = JSON.parse(modal.dataset.selectedIds || '[]');
    if (!ids.length) return;
    
    // Show progress
    const progress = document.getElementById('bulkStreamKeyProgress');
    const progressText = document.getElementById('bulkStreamKeyProgressText');
    
    if (progress) progress.classList.remove('hidden');
    
    let success = 0, failed = 0;
    
    for (let i = 0; i < ids.length; i++) {
      const id = ids[i];
      if (progressText) progressText.textContent = `${i + 1} / ${ids.length} processing...`;
      
      try {
        const res = await fetch(`/youtube/broadcasts/${id}/bind-stream`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ streamId })
        });
        
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || 'Bind failed');
        
        success++;
      } catch (err) {
        console.error(`Failed to bind stream for ${id}:`, err.message);
        failed++;
      }
    }
    
    if (progress) progress.classList.add('hidden');
    
    // Show result
    toast(`Stream key binding complete — Success: ${success}, Failed: ${failed}`, failed > 0 ? 'error' : 'success');
    
    closeBulkStreamKeyModal();
    
    // Uncheck all and refresh
    const selAll = document.getElementById('yt-select-all');
    if (selAll) selAll.checked = false;
    document.querySelectorAll('.yt-select-item').forEach(b => b.checked = false);
    
    loadList();
  }
  
  // Bulk Thumbnail Upload
  function openBulkThumbnailUpload(ids){
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = async () => {
      if (!input.files || !input.files[0]) return;
      
      const file = input.files[0];
      const count = ids.length;
      
      if (!confirm(`Upload this thumbnail to ${count} selected broadcasts?`)) return;
      
      // Show progress toast
      const progressToast = document.createElement('div');
      progressToast.className = 'fixed bottom-4 right-4 bg-dark-800 border border-blue-600 rounded-lg p-4 shadow-lg z-[100]';
      progressToast.innerHTML = `
        <div class="flex items-center gap-3">
          <i class="ti ti-loader animate-spin text-blue-400 text-xl"></i>
          <div>
            <div class="font-medium text-white">Uploading thumbnails...</div>
            <div class="text-sm text-gray-400" id="bulk-thumb-progress">0 / ${count}</div>
          </div>
        </div>
      `;
      document.body.appendChild(progressToast);
      
      let success = 0, failed = 0;
      const progressEl = document.getElementById('bulk-thumb-progress');
      
      for (let i = 0; i < ids.length; i++) {
        const id = ids[i];
        if (progressEl) progressEl.textContent = `${i + 1} / ${count} processing...`;
        
        try {
          const fd = new FormData();
          fd.append('file', file);
          
          const res = await fetch(`/youtube/broadcasts/${id}/thumbnail`, { 
            method: 'POST', 
            body: fd 
          });
          
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || 'Upload failed');
          
          success++;
          
          // Update cache bust for this broadcast
          ytThumbBust[id] = Date.now();
        } catch (err) {
          console.error(`Failed to upload thumbnail for ${id}:`, err.message);
          failed++;
        }
      }
      
      // Remove progress toast
      document.body.removeChild(progressToast);
      
      // Show result
      toast(`Bulk thumbnail upload complete — Success: ${success}, Failed: ${failed}`, failed > 0 ? 'error' : 'success');
      
      // Uncheck all and refresh
      const selAll = document.getElementById('yt-select-all');
      if (selAll) selAll.checked = false;
      document.querySelectorAll('.yt-select-item').forEach(b => b.checked = false);
      
      loadList();
    };
    input.click();
  }
  
  // Scroll to Top Button Logic
  (function() {
    const scrollBtn = document.getElementById('scrollToTopBtn');
    if (!scrollBtn) return;
    
    // Show/hide button based on scroll position
    window.addEventListener('scroll', () => {
      if (window.scrollY > 300) {
        scrollBtn.classList.remove('hidden');
      } else {
        scrollBtn.classList.add('hidden');
      }
    });
    
    // Scroll to top when clicked
    scrollBtn.addEventListener('click', () => {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });
  })();
  
  // Mobile Bulk Menu Logic
  (function() {
    const menuBtn = document.getElementById('mobile-bulk-menu-btn');
    const menu = document.getElementById('mobile-bulk-menu');
    
    if (menuBtn && menu) {
      menuBtn.addEventListener('click', () => {
        menu.classList.toggle('hidden');
      });
      
      // Close menu when clicking outside
      document.addEventListener('click', (e) => {
        if (!menuBtn.contains(e.target) && !menu.contains(e.target)) {
          menu.classList.add('hidden');
        }
      });
    }
    
    // Sync mobile and desktop select all checkboxes
    const selectAll = document.getElementById('yt-select-all');
    const selectAllMobile = document.getElementById('yt-select-all-mobile');
    
    if (selectAll && selectAllMobile) {
      selectAll.addEventListener('change', () => {
        selectAllMobile.checked = selectAll.checked;
      });
      
      selectAllMobile.addEventListener('change', () => {
        selectAll.checked = selectAllMobile.checked;
        // Trigger the same event as desktop
        selectAll.dispatchEvent(new Event('change'));
      });
    }
    
    // Sync mobile bulk action buttons with desktop
    const bulkEdit = document.getElementById('yt-bulk-edit');
    const bulkEditMobile = document.getElementById('yt-bulk-edit-mobile');
    const bulkThumbnail = document.getElementById('yt-bulk-thumbnail');
    const bulkThumbnailMobile = document.getElementById('yt-bulk-thumbnail-mobile');
    const bulkStreamkey = document.getElementById('yt-bulk-streamkey');
    const bulkStreamkeyMobile = document.getElementById('yt-bulk-streamkey-mobile');
    const bulkDelete = document.getElementById('yt-bulk-delete');
    const bulkDeleteMobile = document.getElementById('yt-bulk-delete-mobile');
    
    if (bulkEditMobile && bulkEdit) {
      bulkEditMobile.addEventListener('click', () => bulkEdit.click());
    }
    if (bulkThumbnailMobile && bulkThumbnail) {
      bulkThumbnailMobile.addEventListener('click', () => bulkThumbnail.click());
    }
    if (bulkStreamkeyMobile && bulkStreamkey) {
      bulkStreamkeyMobile.addEventListener('click', () => bulkStreamkey.click());
    }
    if (bulkDeleteMobile && bulkDelete) {
      bulkDeleteMobile.addEventListener('click', () => bulkDelete.click());
    }
    
    // Sync disabled state
    const observer = new MutationObserver(() => {
      if (bulkEdit && bulkEditMobile) bulkEditMobile.disabled = bulkEdit.disabled;
      if (bulkThumbnail && bulkThumbnailMobile) bulkThumbnailMobile.disabled = bulkThumbnail.disabled;
      if (bulkStreamkey && bulkStreamkeyMobile) bulkStreamkeyMobile.disabled = bulkStreamkey.disabled;
      if (bulkDelete && bulkDeleteMobile) bulkDeleteMobile.disabled = bulkDelete.disabled;
      if (menuBtn) menuBtn.disabled = bulkEdit?.disabled ?? true;
    });
    
    if (bulkEdit) observer.observe(bulkEdit, { attributes: true, attributeFilter: ['disabled'] });
  })();
</script>

